<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Режим разработчика - Управление кругами</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #password { margin-bottom: 20px; display: flex; gap: 10px; align-items: center; }
        #content { display: none; width: 100%; max-width: 1200px; display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; }
        #leftPanel { /* Пустой, если не нужно */ }
        #rightPanel { display: flex; flex-direction: column; gap: 10px; }
        #canvasContainer { flex: 1; display: flex; justify-content: center; }
        select { padding: 5px; }
        button { padding: 10px; }
        #canvas { border: 1px solid #000; cursor: crosshair; }
        #status { margin-top: 10px; font-size: 14px; color: #555; text-align: center; }
    </style>
</head>
<body>
    <div id="container">
        <div id="password">
            <label for="passwordInput">Пароль:</label>
            <input type="password" id="passwordInput">
            <button id="enterBtn">Войти</button>
        </div>
        <div id="content">
            <div id="leftPanel">
                <!-- Пусто, чтобы канвас был слева -->
            </div>
            <div id="canvasContainer">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            <div id="rightPanel">
                <div id="controls">
                    <button id="addCircleBtn">Добавить круг</button>
                    <button id="removeCircleBtn">Удалить круг</button>
                    <button id="saveChangesBtn">Сохранить изменения</button>
                    <button id="exportBtn">Экспорт JSON</button>
                    <input type="file" id="importInput" accept=".json" style="display: none;">
                    <button id="importBtn">Импорт JSON</button>
                    <button id="switchToUserBtn">Перейти в пользовательский режим</button>
                </div>
                <div id="filters">
                    <select id="groupSelect"><option>Выберите Сорт</option></select>
                    <select id="subgroupSelect"><option>Выберите Круг</option></select>
                </div>
                <div id="status">Наведите курсор на круг и нажмите Delete для удаления. Перетаскивайте для перемещения.</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const background = new Image();
        background.src = 'https://github.com/oluneva/my_site/raw/main/my-image.jpg';

        // Загружаем circles из репозитория
        let circles = [];
        let data = [];
        let filteredData = [];
        let selectedFilters = { group: '', subgroup: '' };
        let draggedCircle = null;
        let newCircles = new Set();

        // Функция загрузки circles из circles_export.json
        async function loadCircles() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error('Файл не найден');
                const data = await response.json();
                circles = data.map(c => ({
                    ...c,
                    id: String(c.id || '') // Конвертируем id в строку
                }));
            } catch (e) {
                circles = [];
            }
            renderCircles();
            updateFilters();
        }

        // Функция загрузки CSV
        async function loadCSV() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error('Файл не найден');
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');
                const csvText = decoder.decode(buffer);
                data = parseCSV(csvText);
                if (data.length === 0) throw new Error('CSV пустой или некорректный');
                filteredData = data;
                updateFilters();
            } catch (e) {
                data = [
                    { Сорт: 'Сорт1', Подгруппа: 'Подгруппа1' },
                    { Сорт: 'Сорт2', Подгруппа: 'Подгруппа2' }
                ];
                filteredData = data;
                updateFilters();
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            if (lines.length < 1) return [];
            const headers = lines[0].split(',').map(h => h.trim());
            const expectedHeaders = ['Класс', 'Подкласс', 'Тип', 'Подтип', 'Сорт', 'Подгруппа'];
            if (!expectedHeaders.every(h => headers.includes(h))) {
                return [];
            }
            return lines.slice(1).map(line => {
                const values = line.split(',');
                let obj = {};
                headers.forEach((h, i) => obj[h] = values[i]?.trim() || '');
                return obj;
            }).filter(obj => obj['Класс']);
        }

        function updateFilters() {
            const selects = ['groupSelect', 'subgroupSelect'];
            const keys = ['Сорт', 'Подгруппа'];
            selects.forEach((id, i) => {
                const select = document.getElementById(id);
                select.innerHTML = `<option>Выберите ${i === 0 ? 'Сорт' : 'Круг'}</option>`;
                if (i === 0) {
                    const unique = [...new Set(filteredData.map(d => d[keys[i]]))].filter(v => v);
                    unique.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });
                } else {
                    // Фильтрация кругов с проверками типов
                    const matchingCircles = circles.filter(c => c && typeof c.id === 'string' && c.id.trim() !== '').filter(circle => {
                        const circleType = circle.type || 'Сорт1';
                        return (!selectedFilters.group || circleType.includes(selectedFilters.group)) &&
                               (!selectedFilters.subgroup || circleType.includes(selectedFilters.subgroup));
                    });
                    const uniqueIds = [...new Set(matchingCircles.map(c => c.id))];
                    uniqueIds.forEach(id => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = id;
                        select.appendChild(option);
                    });
                }
            });
        }

        function cascadeFilters(changedKey) {
            const keys = ['Сорт', 'Подгруппа'];
            const index = keys.indexOf(changedKey);
            filteredData = data.filter(d => {
                return keys.slice(0, index + 1).every(key => !selectedFilters[key.toLowerCase()] || d[key] === selectedFilters[key.toLowerCase()]);
            });
            updateFilters();
        }

        document.getElementById('groupSelect').addEventListener('change', e => { selectedFilters.group = e.target.value; cascadeFilters('Сорт'); });
        document.getElementById('subgroupSelect').addEventListener('change', e => { selectedFilters.subgroup = e.target.value; cascadeFilters('Подгруппа'); });

        function renderCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            circles.forEach(circle => {
                if (!circle || typeof circle.id !== 'string' || !circle.id.trim()) return;
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, 15, 0, 2 * Math.PI);
                ctx.fillStyle = newCircles.has(circle.id) ? 'red' : 'orange';
                ctx.fill();
                ctx.stroke();
            });
        }

        function generateId() {
            // Убедимся, что id — строки
            const existingIds = circles.map(c => String(c.id)).filter(id => id && id.startsWith('circle_'));
            let maxNum = 0;
            existingIds.forEach(id => {
                const num = parseInt(id.replace('circle_', ''));
                if (!isNaN(num) && num > maxNum) maxNum = num;
            });
            return 'circle_' + (maxNum + 1);
        }

        function addCircleAtPosition(x, y) {
            const id = generateId();
            circles.push({ id, x, y });
            newCircles.add(id);
            renderCircles();
            updateFilters();
        }

        document.getElementById('addCircleBtn').addEventListener('click', () => {
            const x = canvas.width / 2;
            const y = canvas.height / 2;
            addCircleAtPosition(x, y);
        });

        document.getElementById('removeCircleBtn').addEventListener('click', () => {
            if (circles.length > 0) {
                const removed = circles.pop();
                newCircles.delete(removed.id);
                renderCircles();
                updateFilters();
            }
        });

        function getCircleAt(x, y) {
            return circles.find(circle => {
                if (!circle || typeof circle.id !== 'string') return false;
                const dx = x - circle.x;
                const dy = y - circle.y;
                return Math.sqrt(dx * dx + dy * dy) < 15;
            });
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            draggedCircle = getCircleAt(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedCircle) {
                const rect = canvas.getBoundingClientRect();
                draggedCircle.x = e.clientX - rect.left;
                draggedCircle.y = e.clientY - rect.top;
                renderCircles();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedCircle = null;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const circleToDelete = getCircleAt(x, y);
                if (circleToDelete) {
                    circles = circles.filter(c => c !== circleToDelete);
                    newCircles.delete(circleToDelete.id);
                    renderCircles();
                    updateFilters();
                }
            }
        });

        background.onload = () => {
            renderCircles();
        };

        // Кнопка "Сохранить изменения" — напоминание экспортировать
        document.getElementById('saveChangesBtn').addEventListener('click', () => {
            // Можно добавить сообщение в консоль, если нужно: console.log('Изменения не сохранены автоматически. Нажмите "Экспорт JSON" для скачивания файла и загрузите его в репозиторий вручную.');
        });

        // Экспорт JSON
        document.getElementById('exportBtn').addEventListener('click', () => {
            const dataStr = JSON.stringify(circles, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'circles_export.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Импорт JSON
        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('importInput').click();
        });

        document.getElementById('importInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        circles = JSON.parse(event.target.result).map(c => ({
                            ...c,
                            id: String(c.id || '')
                        }));
                        renderCircles();
                        updateFilters();
                    } catch (err) {
                        // Можно добавить console.log для ошибок: console.log('Ошибка импорта: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        // Пароль для доступа (для режима разработчика - "developer")
        document.getElementById('enterBtn').addEventListener('click', () => {
            const password = document.getElementById('passwordInput').value;
            if (password === 'developer') {
                document.getElementById('password').style.display = 'none';
                document.getElementById('content').style.display = 'flex';
                // Загружаем данные после входа
                loadCircles();
                loadCSV();
            } else {
                alert('Неверный пароль');
            }
        });
    </script>
</body>
</html>
