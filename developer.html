<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Режим разработчика - Управление кругами</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #77c98c; /* Бледно-зелёный, как общий фон */ }
        #container { display: flex; flex-direction: column; align-items: center; }
        #content { width: 100%; max-width: 1200px; display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; }
        #leftPanel { /* Пусто, чтобы канвас был слева */ }
        #rightPanel { display: flex; flex-direction: column; gap: 10px; }
        #canvasContainer { flex: 1; display: flex; justify-content: center; }
        select { padding: 5px; }
        button { padding: 10px; }
        #canvas { border: 1px solid #000; cursor: crosshair; }
        #status { margin-top: 10px; font-size: 14px; color: #555; text-align: center; }
        #tooltip { display: none; position: absolute; background: #fff; border: 1px solid #000; padding: 5px; font-size: 12px; pointer-events: none; z-index: 1000; }
    </style>
</head>
<body>
    <div id="container">
        <div id="content">
            <div id="leftPanel"></div>
            <div id="canvasContainer">
                <canvas id="canvas" width="800" height="600"></canvas>
                <div id="tooltip"></div> <!-- Всплывающее сообщение -->
            </div>
            <div id="rightPanel">
                <div id="controls">
                    <button id="addCircleBtn">Добавить круг</button>
                    <button id="removeCircleBtn">Удалить круг</button>
                    <button id="saveChangesBtn">Сохранить изменения</button>
                    <button id="exportBtn">Экспорт JSON</button>
                    <input type="file" id="importInput" accept=".json" style="display: none;">
                    <button id="importBtn">Ипорт JSON</button>
                    <button id="switchToUserBtn">Перейти в пользовательский режим</button>
                </div>
                <div id="filters">
                    <select id="groupSelect">
                        <option>Выберите Сорт</option>
                    </select>
                    <select id="subgroupSelect">
                        <option>Выберите Круг</option>
                    </select>
                </div>
                <div id="status">Наведите курсор на круг и нажмите Delete для удаления. Перетаскивайте для перемещения.</div>
            </div>
        </div>
    </div>

    <script>
        // Инициализируем интерфейс сразу без пароля
        const ctx = document.getElementById('canvas').getContext('2d');
        const background = new Image();
        let hasBackground = false;

        let circles = [];
        let data = [];
        let filteredData = [];
        let selectedFilters = { 'Сорт': '', 'Круг': '' };
        let draggedCircle = null;
        let newCircles = new Set();
        let maxLoadedId = 0; // Максимальный ID из загруженных кругов
        let newCircleOffsetX = 0; // Смещение для новых кругов вправо

        async function loadCircles() {
            let ids;  // ДОБАВЛЕНО: объявление переменной ids
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error('Файл не найден');
                const data = await response.json();
                circles = data.map(c => ({
                    ...c,
                    id: String(c.id || '')
                }));
                // Предполагаю, что у тебя есть массив ids вроде ['circle_1', 'circle_2', ..., 'circle_13']
const numericIds = ids.map(id => parseInt(id.replace('circle_', ''), 10)).filter(id => !isNaN(id));
const maxId = numericIds.length > 0 ? Math.max(...numericIds) : 0;
console.log('Максимальный ID из загруженных:', maxId);  // Теперь будет 13!
            } catch (e) {
                console.error('Ошибка загрузки circles_export.json:', e);
                circles = []; // Пустой массив, если файл не найден
                maxLoadedId = 0;
                newCircles.clear();
            }
            renderCircles();
            updateFilters();
        }

        async function loadCSV() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error('Файл не найден');
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');
                const csvText = decoder.decode(buffer);
                data = parseCSV(csvText);
                console.log('Загруженные данные из CSV:', data);
                if (data.length === 0) throw new Error('CSV пустой или некорректный');
                filteredData = data; // Изначально полный data
                updateFilters();
            } catch (e) {
                console.error('Ошибка загрузки CSV:', e);
                // Fallback данные для тестирования
                data = [
                    { Сорт: 'Сорт1', Круг: 'Круг1' },
                    { Сорт: 'Сорт1', Круг: 'Круг2' },
                    { Сорт: 'Сорт2', Круг: 'Круг3' }
                ];
                filteredData = data;
                updateFilters();
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            if (lines.length < 1) return [];
            // Разделитель ';'
            const headers = lines[0].split(';').map(h => h.trim());
            console.log('Заголовки CSV:', headers);
            return lines.slice(1).map(line => {
                const values = line.split(';').map(v => v.trim().replace(/^"|"$/g, ''));
                let obj = {};
                headers.forEach((h, i) => obj[h] = values[i] || '');
                return obj;
            });
        }

        function updateFilters() {
            const selects = ['groupSelect', 'subgroupSelect'];
            const keys = ['Сорт', 'Круг'];
            selects.forEach((id, i) => {
                const select = document.getElementById(id);
                select.innerHTML = `<option value="">Выберите ${keys[i]}</option>`;
                const unique = [...new Set(filteredData.map(d => d[keys[i]]))].filter(v => v);
                console.log(`Уникальные для ${keys[i]}:`, unique);
                unique.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.textContent = val;
                    select.appendChild(option);
                });
                select.value = selectedFilters[keys[i]]; // Устанавливаем выбранное значение
            });
        }

        function cascadeFilters(changedKey) {
            const keys = ['Сорт', 'Круг'];
            const selects = ['groupSelect', 'subgroupSelect'];
            const index = keys.indexOf(changedKey);
            if (index === 0) { // Изменён "Сорт"
                selectedFilters['Круг'] = ''; // Сбрасываем выбор "Круг"
                filteredData = selectedFilters['Сорт'] ? data.filter(d => d['Сорт'] === selectedFilters['Сорт']) : data; // Фильтруем data по "Сорт"
                updateFilters(); // Обновляем оба селекта на основе filteredData
                renderCircles(); // Перерисовываем круги (без фильтра по "Круг")
            } else if (index === 1) { // Изменён "Круг"
                // Находим соответствующий "Сорт" из data
                const matchingData = data.find(d => d['Круг'] === selectedFilters['Круг']);
                if (matchingData) {
                    selectedFilters['Сорт'] = matchingData['Сорт'];
                    // Фильтруем filteredData по этому "Сорт"
                    filteredData = data.filter(d => d['Сорт'] === selectedFilters['Сорт']);
                } else {
                    selectedFilters['Сорт'] = ''; // Если не найдено, сбрасываем
                    filteredData = data;
                }
                updateFilters(); // Обновляем оба селекта (чтобы отразить "Сорт")
                renderCircles(); // Фильтруем отображение кругов по "Круг"
            }
        }

        function getCircleAt(x, y) {
    console.log('Поиск круга по координатам:', x, y);  // Добавь для отладки
    
    // Предполагаю, что у тебя есть глобальный массив circles = [{id: 'circle_1', x: ..., y: ..., radius: ...}, ...]
    for (let circle of circles) {  // Замени 'circles' на имя твоего массива кругов
        const dx = x - circle.x;  // centerX круга
        const dy = y - circle.y;  // centerY круга
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        console.log(`Проверяю ${circle.id}: расстояние = ${distance.toFixed(2)}, радиус = ${circle.radius}`);  // Отладка для каждого круга
        
        if (distance <= circle.radius + 10) {  // +10px для "подушки" (увеличь, если нужно)
            console.log(`Найден! ID: ${circle.id}, расстояние: ${distance.toFixed(2)}`);
            return circle;
        }
    }
    console.log('Ни один круг не найден');
    return null;
}

        function renderCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (hasBackground) {
                ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#77c98c'; // Бледно-зелёный fallback фон
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            circles.forEach(circle => {
                const isVisible = !selectedFilters['Круг'] || circle.id === selectedFilters['Круг'];
                if (isVisible) {
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, 15, 0, 2 * Math.PI);
                    // Цвет: красный для новых (newCircles), оранжевый для загруженных
                    ctx.fillStyle = newCircles.has(circle.id) ? 'red' : 'orange';
                    ctx.fill();
                    ctx.stroke();
                }
            });
        }

        // Загрузка фона (из URL, с fallback на бледно-зелёный)
        background.onload = () => {
            console.log('Фон загружен успешно!');
            hasBackground = true;
            renderCircles();
        };
        background.onerror = () => {
            console.log('Фон не найден, используем бледно-зелёный fallback.');
            hasBackground = false;
            renderCircles();
        };
        background.src = 'https://raw.githubusercontent.com/oluneva/my_site/main/my-image.jpg'; // URL фона

        // Загрузка данных
        loadCircles();
        loadCSV();

        // Обработчики событий
        document.getElementById('addCircleBtn').addEventListener('click', () => {
            // Генерируем новый ID: maxLoadedId + 1
            const newId = maxLoadedId + 1;
            maxLoadedId = newId; // Увеличиваем для следующего
            // Позиция: центр + сдвиг вправо
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const x = centerX + newCircleOffsetX;
            const y = centerY;
            newCircleOffsetX += 30; // Сдвиг на 30 пикселей вправо для следующего
            circles.push({ x, y, id: String(newId) });
            newCircles.add(String(newId)); // Новый круг — красный
            renderCircles();
        });

        document.getElementById('removeCircleBtn').addEventListener('click', () => {
            const id = prompt('Введите ID круга для удаления:');
            if (id) {
                circles = circles.filter(c => c.id !== String(id));
                newCircles.delete(String(id));
                renderCircles();
            }
        });

        document.getElementById('saveChangesBtn').addEventListener('click', () => {
            localStorage.setItem('circles', JSON.stringify(circles));
            // После сохранения новые круги становятся "загруженными" — очищаем newCircles
            newCircles.clear();
            renderCircles(); // Перерисовка: все теперь оранжевые
            alert('Изменения сохранены! Новые круги теперь оранжевые.');
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            const dataStr = JSON.stringify(circles, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'circles_export.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('importInput').click();
        });

        document.getElementById('importInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        circles = JSON.parse(event.target.result).map(c => ({
                            ...c,
                            id: String(c.id || '')
                        }));
                        // После импорта пересчитываем maxLoadedId
                        maxLoadedId = Math.max(...circles.map(c => parseInt(c.id) || 0)) || 0;
                        newCircles.clear(); // Импортированные — оранжевые
                        newCircleOffsetX = 0; // Сброс смещения
                        renderCircles();
                        updateFilters();
                    } catch (err) {
                        alert('Ошибка при импорте JSON!');
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('switchToUserBtn').addEventListener('click', () => {
            window.location.href = 'user.html';
        });

        document.getElementById('groupSelect').addEventListener('change', (e) => {
            selectedFilters['Сорт'] = e.target.value;
            cascadeFilters('Сорт');
        });

        document.getElementById('subgroupSelect').addEventListener('change', (e) => {
            selectedFilters['Круг'] = e.target.value;
            cascadeFilters('Круг');
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            draggedCircle = getCircleAt(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedCircle) {
                const rect = canvas.getBoundingClientRect();
                draggedCircle.x = e.clientX - rect.left;
                draggedCircle.y = e.clientY - rect.top;
                renderCircles();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedCircle = null;
        });

canvas.addEventListener('mouseover', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const circle = getCircleAt(x, y);  // Обязательно объявить circle ЗДЕСЬ!
    
    // Код для отладки — добавь сюда (после объявления circle)
    console.log('Курсоры на canvas:', x, y);
    if (circle) {
        console.log('Найден круг с ID:', circle.id);  // Теперь будет "circle_1", "circle_2" и т.д.
        console.log('Ищу в data:', data.find(d => d['Круг'] === circle.id));
    } else {
        console.log('Круг не найден');
    }
    
    // Остальной код (tooltip и т.д.)
    const tooltip = document.getElementById('tooltip');
    
    if (circle) {
        // Ищем совпадение в данных из CSV
        let matchingData = data.find(d => d['Круг'] === circle.id);  // Точное совпадение (например, "circle_1" === "circle_1")
        
        // Если не найдено, пробуем числовое (если ID="circle_1", ищем d['Круг'] === 1)
        if (!matchingData) {
            const numericId = parseInt(circle.id.replace('circle_', ''), 10);  // Из "circle_1" получаем 1
            if (!isNaN(numericId)) {
                matchingData = data.find(d => d['Круг'] === numericId);
            }
        }
        
        // Определяем текст для tooltip
        const sort = matchingData ? matchingData['Сорт'] : 'Неизвестно';
        tooltip.textContent = `Сорт: ${sort}`;
        
        // Показываем tooltip рядом с курсором
        tooltip.style.display = 'block';
        tooltip.style.left = `${e.clientX + 10}px`;  // Смещение вправо
        tooltip.style.top = `${e.clientY + 10}px`;   // Смещение вниз
    } else {
        // Если курсор не над кругом, ничего не делаем (tooltip скрыт по умолчанию)
    }
});
        
        canvas.addEventListener('mouseout', () => {
    const tooltip = document.getElementById('tooltip');
    tooltip.style.display = 'none';
});

        canvas.addEventListener('keydown', (e) => {
            if (e.key === 'Delete') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const index = circles.findIndex(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15);
                if (index !== -1) {
                    newCircles.delete(circles[index].id);
                    circles.splice(index, 1);
                    renderCircles();
                }
            }
        });

        canvas.tabIndex = 0; // Для фокуса на canvas
    </script>
</body>
</html>






