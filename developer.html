<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–†–µ–∂–∏–º —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫—Ä—É–≥–∞–º–∏</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #content { width: 100%; max-width: 1200px; display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; }
        #leftPanel { /* –ü—É—Å—Ç–æ, —á—Ç–æ–±—ã –∫–∞–Ω–≤–∞—Å –±—ã–ª —Å–ª–µ–≤–∞ */ }
        #rightPanel { display: flex; flex-direction: column; gap: 10px; }
        #canvasContainer { flex: 1; display: flex; justify-content: center; }
        select { padding: 5px; }
        button { padding: 10px; }
        #canvas { border: 1px solid #000; cursor: crosshair; }
        #status { margin-top: 10px; font-size: 14px; color: #555; text-align: center; }
    </style>
</head>
<body>
    <div id="container">
        <div id="content">
            <div id="leftPanel"></div>
            <div id="canvasContainer">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            <div id="rightPanel">
                <div id="controls">
                    <button id="addCircleBtn">–î–æ–±–∞–≤–∏—Ç—å –∫—Ä—É–≥</button>
                    <button id="removeCircleBtn">–£–¥–∞–ª–∏—Ç—å –∫—Ä—É–≥</button>
                    <button id="saveChangesBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è</button>
                    <button id="exportBtn">–≠–∫—Å–ø–æ—Ä—Ç JSON</button>
                    <input type="file" id="importInput" accept=".json" style="display: none;">
                    <button id="importBtn">–ò–ø–æ—Ä—Ç JSON</button>
                    <button id="switchToUserBtn">–ü–µ—Ä–µ–π—Ç–∏ –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —Ä–µ–∂–∏–º</button>
                </div>
                <div id="filters">
                    <select id="groupSelect">
                        <option>–í—ã–±–µ—Ä–∏—Ç–µ –°–æ—Ä—Ç</option>
                    </select>
                    <select id="subgroupSelect">
                        <option>–í—ã–±–µ—Ä–∏—Ç–µ –ö—Ä—É–≥</option>
                    </select>
                </div>
                <div id="status">–ù–∞–≤–µ–¥–∏—Ç–µ –∫—É—Ä—Å–æ—Ä –Ω–∞ –∫—Ä—É–≥ –∏ –Ω–∞–∂–º–∏—Ç–µ Delete –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è. –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è.</div>
            </div>
        </div>
    </div>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å—Ä–∞–∑—É –±–µ–∑ –ø–∞—Ä–æ–ª—è
        const ctx = document.getElementById('canvas').getContext('2d');
        const background = new Image();
        let hasBackground = false;

        let circles = [];
        let data = [];
        let filteredData = [];
        let selectedFilters = { '–°–æ—Ä—Ç': '', '–ö—Ä—É–≥': '' };
        let draggedCircle = null;
        let newCircles = new Set();

        async function loadCircles() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω');
                const data = await response.json();
                circles = data.map(c => ({
                    ...c,
                    id: String(c.id || '')
                }));
            } catch (e) {
                circles = [];
            }
            renderCircles();
            updateFilters();
        }

        async function loadCSV() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω');
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');
                const csvText = decoder.decode(buffer);
                data = parseCSV(csvText);
                console.log('–ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ CSV:', data);
                if (data.length === 0) throw new Error('CSV –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π');
                filteredData = data;
                updateFilters();
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ CSV:', e);
                data = [
                    { –°–æ—Ä—Ç: '–°–æ—Ä—Ç1', –ö—Ä—É–≥: '–ö—Ä—É–≥1' },
                    { –°–æ—Ä—Ç: '–°–æ—Ä—Ç2', –ö—Ä—É–≥: '–ö—Ä—É–≥2' }
                ];
                filteredData = data;
                updateFilters();
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            if (lines.length < 1) return [];
            // –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å ';'
            const headers = lines[0].split(';').map(h => h.trim());
            console.log('–ó–∞–≥–æ–ª–æ–≤–∫–∏ CSV:', headers);
            return lines.slice(1).map(line => {
                const values = line.split(';').map(v => v.trim().replace(/^"|"$/g, ''));
                let obj = {};
                headers.forEach((h, i) => obj[h] = values[i] || '');
                return obj;
            });
        }

        function updateFilters() {
            const selects = ['groupSelect', 'subgroupSelect'];
            const keys = ['–°–æ—Ä—Ç', '–ö—Ä—É–≥'];
            selects.forEach((id, i) => {
                const select = document.getElementById(id);
                select.innerHTML = `<option>–í—ã–±–µ—Ä–∏—Ç–µ ${keys[i]}</option>`;
                const unique = [...new Set(filteredData.map(d => d[keys[i]]))].filter(v => v);
                console.log(`–£–Ω–∏–∫–∞–ª—å–Ω—ã–µ –¥–ª—è ${keys[i]}:`, unique);
                unique.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.textContent = val;
                    select.appendChild(option);
                });
            });
        }

        function cascadeFilters(changedKey) {
            const keys = ['–°–æ—Ä—Ç', '–ö—Ä—É–≥'];
            const selects = ['groupSelect', 'subgroupSelect'];
            const index = keys.indexOf(changedKey);
            if (index === 0) {
                selectedFilters['–ö—Ä—É–≥'] = '';
                filteredData = selectedFilters['–°–æ—Ä—Ç'] ? data.filter(d => d['–°–æ—Ä—Ç'] === selectedFilters['–°–æ—Ä—Ç']) : data;
                updateFilters();
                document.getElementById('subgroupSelect').value = '';
            } else if (index === 1) {
                renderCircles();
            }
        }

        function renderCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (hasBackground) {
                ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#f0f0f0'; // –°–µ—Ä—ã–π —Ñ–æ–Ω, –µ—Å–ª–∏ –Ω–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            circles.forEach(circle => {
                const isVisible = !selectedFilters['–ö—Ä—É–≥'] || circle.id === selectedFilters['–ö—Ä—É–≥'];
                if (isVisible) {
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, 15, 0, 2 * Math.PI);
                    ctx.fillStyle = newCircles.has(circle.id) ? 'red' : 'blue';
                    ctx.fill();
                    ctx.stroke();
                }
            });
        }

        background.onload = () => {
            hasBackground = true;
            renderCircles();
        };
        background.onerror = () => {
            console.log('–§–æ–Ω –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω, —Ä–∏—Å—É–µ–º –±–µ–∑ –Ω–µ–≥–æ.');
            hasBackground = false;
            renderCircles();
        };
        background.src = 'https://raw.githubusercontent.com/oluneva/my_site/main/background.jpg';

        loadCircles();
        loadCSV();

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        document.getElementById('addCircleBtn').addEventListener('click', () => {
            const x = Math.random() * (canvas.width - 30) + 15;
            const y = Math.random() * (canvas.height - 30) + 15;
            const id = prompt('–í–≤–µ–¥–∏—Ç–µ ID –∫—Ä—É–≥–∞:');
            if (id) {
                circles.push({ x, y, id: String(id) });
                newCircles.add(String(id));
                renderCircles();
            }
        });

        document.getElementById('removeCircleBtn').addEventListener('click', () => {
            const id = prompt('–í–≤–µ–¥–∏—Ç–µ ID –∫—Ä—É–≥–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:');
            if (id) {
                circles = circles.filter(c => c.id !== String(id));
                newCircles.delete(String(id));
                renderCircles();
            }
        });

        document.getElementById('saveChangesBtn').addEventListener('click', () => {
            localStorage.setItem('circles', JSON.stringify(circles));
            alert('–ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!');
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            const dataStr = JSON.stringify(circles, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'circles_export.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('importInput').click();
        });

        document.getElementById('importInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        circles = JSON.parse(event.target.result).map(c => ({
                            ...c,
                            id: String(c.id || '')
                        }));
                        renderCircles();
                        updateFilters();
                    } catch (err) {
                        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ JSON!');
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('switchToUserBtn').addEventListener('click', () => {
            window.location.href = 'user.html';
        });

        document.getElementById('groupSelect').addEventListener('change', (e) => {
            selectedFilters['–°–æ—Ä—Ç'] = e.target.value;
            cascadeFilters('–°–æ—Ä—Ç');
        });

        document.getElementById('subgroupSelect').addEventListener('change', (e) => {
            selectedFilters['–ö—Ä—É–≥'] = e.target.value;
            cascadeFilters('–ö—Ä—É–≥');
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            draggedCircle = circles.find(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedCircle) {
                const rect = canvas.getBoundingClientRect();
                draggedCircle.x = e.clientX - rect.left;
                draggedCircle.y = e.clientY - rect.top;
                renderCircles();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedCircle = null;
        });

        canvas.addEventListener('keydown', (e) => {
            if (e.key === 'Delete') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const index = circles.findIndex(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15);
                if (index !== -1) {
                    newCircles.delete(circles[index].id);
                    circles.splice(index, 1);
                    renderCircles();
                }
            }
        });

        canvas.tabIndex = 0; // –î–ª—è —Ñ–æ–∫—É—Å–∞ –Ω–∞ canvas
    </script>
</body>
</html>

–¢–µ–ø–µ—Ä—å, –µ—Å–ª–∏ —Ñ–æ–Ω –Ω–µ –∑–∞–≥—Ä—É–∑–∏—Ç—Å—è, –∫–∞–Ω–≤–∞—Å –±—É–¥–µ—Ç –∏–º–µ—Ç—å —Å–µ—Ä—ã–π —Ñ–æ–Ω, –∏ –∫—Ä—É–≥–∏ –æ—Ç–æ–±—Ä–∞–∑—è—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ ‚Äî –¥–æ–ª–∂–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å! –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ persists, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ (F12) –Ω–∞ –æ—à–∏–±–∫–∏. üòä

–Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –∫–∞—Ä—Ç–∏–Ω–∫–∞ - —Ä–∏—Å—É–Ω–æ–∫.

–ö–æ–Ω–µ—á–Ω–æ, –¥–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä—ë–º—Å—è —Å –ø—Ä–æ–±–ª–µ–º–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ–Ω–∞ (–∫–∞—Ä—Ç–∏–Ω–∫–∏). –í –ø—Ä–µ–¥—ã–¥—É—â–µ–º –∫–æ–¥–µ —è –¥–æ–±–∞–≤–∏–ª –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫, –Ω–æ –µ—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Å—ë –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è, —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–≤—è–∑–∞–Ω–æ —Å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å—é —Ñ–∞–π–ª–∞ –Ω–∞ GitHub (–Ω–∞–ø—Ä–∏–º–µ—Ä, CORS, –∫—ç—à –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ñ–∞–π–ª–∞), –∏–ª–∏ –µ—Å–ª–∏ –≤—ã —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç–µ –ª–æ–∫–∞–ª—å–Ω–æ, —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.

–ß—Ç–æ–±—ã —Ä–µ—à–∏—Ç—å —ç—Ç–æ, —è –æ–±–Ω–æ–≤–∏–ª –∫–æ–¥:

–î–æ–±–∞–≤–∏–ª –±–æ–ª—å—à–µ –æ—Ç–ª–∞–¥–∫–∏ –≤ –∫–æ–Ω—Å–æ–ª—å (—á—Ç–æ–±—ã –≤—ã –º–æ–≥–ª–∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å F12).
–ò–∑–º–µ–Ω–∏–ª –∏—Å—Ç–æ—á–Ω–∏–∫ —Ñ–æ–Ω–∞ –Ω–∞ –ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª ./background.jpg (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—è, —á—Ç–æ –≤—ã –ø–æ–ª–æ–∂–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Ç—É –∂–µ –ø–∞–ø–∫—É, —á—Ç–æ –∏ HTML-—Ñ–∞–π–ª). –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–∞ GitHub, –∑–∞–º–µ–Ω–∏—Ç–µ –æ–±—Ä–∞—Ç–Ω–æ, –Ω–æ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ç–æ –ª—É—á—à–µ.
–ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –∑–∞–≥—Ä—É–∑–∏—Ç—Å—è, –±—É–¥–µ—Ç —Å–µ—Ä—ã–π —Ñ–æ–Ω, –∏ –∫—Ä—É–≥–∏ –æ—Ç–æ–±—Ä–∞–∑—è—Ç—Å—è.
–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª background.jpg –≤ –ø–∞–ø–∫—É —Å HTML –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ. –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ persists, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ –Ω–∞ –æ—à–∏–±–∫–∏ (F12 > Console).

–í–æ—Ç –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π –∫–æ–¥ (—Ç–æ–ª—å–∫–æ –∏–∑–º–µ–Ω—ë–Ω–Ω–∞—è —á–∞—Å—Ç—å —Å–∫—Ä–∏–ø—Ç–∞):

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–†–µ–∂–∏–º —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫—Ä—É–≥–∞–º–∏</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #content { width: 100%; max-width: 1200px; display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; }
        #leftPanel { /* –ü—É—Å—Ç–æ, —á—Ç–æ–±—ã –∫–∞–Ω–≤–∞—Å –±—ã–ª —Å–ª–µ–≤–∞ */ }
        #rightPanel { display: flex; flex-direction: column; gap: 10px; }
        #canvasContainer { flex: 1; display: flex; justify-content: center; }
        select { padding: 5px; }
        button { padding: 10px; }
        #canvas { border: 1px solid #000; cursor: crosshair; }
        #status { margin-top: 10px; font-size: 14px; color: #555; text-align: center; }
    </style>
</head>
<body>
    <div id="container">
        <div id="content">
            <div id="leftPanel"></div>
            <div id="canvasContainer">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            <div id="rightPanel">
                <div id="controls">
                    <button id="addCircleBtn">–î–æ–±–∞–≤–∏—Ç—å –∫—Ä—É–≥</button>
                    <button id="removeCircleBtn">–£–¥–∞–ª–∏—Ç—å –∫—Ä—É–≥</button>
                    <button id="saveChangesBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è</button>
                    <button id="exportBtn">–≠–∫—Å–ø–æ—Ä—Ç JSON</button>
                    <input type="file" id="importInput" accept=".json" style="display: none;">
                    <button id="importBtn">–ò–ø–æ—Ä—Ç JSON</button>
                    <button id="switchToUserBtn">–ü–µ—Ä–µ–π—Ç–∏ –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —Ä–µ–∂–∏–º</button>
                </div>
                <div id="filters">
                    <select id="groupSelect">
                        <option>–í—ã–±–µ—Ä–∏—Ç–µ –°–æ—Ä—Ç</option>
                    </select>
                    <select id="subgroupSelect">
                        <option>–í—ã–±–µ—Ä–∏—Ç–µ –ö—Ä—É–≥</option>
                    </select>
                </div>
                <div id="status">–ù–∞–≤–µ–¥–∏—Ç–µ –∫—É—Ä—Å–æ—Ä –Ω–∞ –∫—Ä—É–≥ –∏ –Ω–∞–∂–º–∏—Ç–µ Delete –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è. –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è.</div>
            </div>
        </div>
    </div>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å—Ä–∞–∑—É –±–µ–∑ –ø–∞—Ä–æ–ª—è
        const ctx = document.getElementById('canvas').getContext('2d');
        const background = new Image();
        let hasBackground = false;

        let circles = [];
        let data = [];
        let filteredData = [];
        let selectedFilters = { '–°–æ—Ä—Ç': '', '–ö—Ä—É–≥': '' };
        let draggedCircle = null;
        let newCircles = new Set();

        async function loadCircles() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω');
                const data = await response.json();
                circles = data.map(c => ({
                    ...c,
                    id: String(c.id || '')
                }));
            } catch (e) {
                circles = [];
            }
            renderCircles();
            updateFilters();
        }

        async function loadCSV() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω');
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');
                const csvText = decoder.decode(buffer);
                data = parseCSV(csvText);
                console.log('–ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ CSV:', data);
                if (data.length === 0) throw new Error('CSV –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π');
                filteredData = data;
                updateFilters();
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ CSV:', e);
                data = [
                    { –°–æ—Ä—Ç: '–°–æ—Ä—Ç1', –ö—Ä—É–≥: '–ö—Ä—É–≥1' },
                    { –°–æ—Ä—Ç: '–°–æ—Ä—Ç2', –ö—Ä—É–≥: '–ö—Ä—É–≥2' }
                ];
                filteredData = data;
                updateFilters();
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            if (lines.length < 1) return [];
            // –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å ';'
            const headers = lines[0].split(';').map(h => h.trim());
            console.log('–ó–∞–≥–æ–ª–æ–≤–∫–∏ CSV:', headers);
            return lines.slice(1).map(line => {
                const values = line.split(';').map(v => v.trim().replace(/^"|"$/g, ''));
                let obj = {};
                headers.forEach((h, i) => obj[h] = values[i] || '');
                return obj;
            });
        }

        function updateFilters() {
            const selects = ['groupSelect', 'subgroupSelect'];
            const keys = ['–°–æ—Ä—Ç', '–ö—Ä—É–≥'];
            selects.forEach((id, i) => {
                const select = document.getElementById(id);
                select.innerHTML = `<option>–í—ã–±–µ—Ä–∏—Ç–µ ${keys[i]}</option>`;
                const unique = [...new Set(filteredData.map(d => d[keys[i]]))].filter(v => v);
                console.log(`–£–Ω–∏–∫–∞–ª—å–Ω—ã–µ –¥–ª—è ${keys[i]}:`, unique);
                unique.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.textContent = val;
                    select.appendChild(option);
                });
            });
        }

        function cascadeFilters(changedKey) {
            const keys = ['–°–æ—Ä—Ç', '–ö—Ä—É–≥'];
            const selects = ['groupSelect', 'subgroupSelect'];
            const index = keys.indexOf(changedKey);
            if (index === 0) {
                selectedFilters['–ö—Ä—É–≥'] = '';
                filteredData = selectedFilters['–°–æ—Ä—Ç'] ? data.filter(d => d['–°–æ—Ä—Ç'] === selectedFilters['–°–æ—Ä—Ç']) : data;
                updateFilters();
                document.getElementById('subgroupSelect').value = '';
            } else if (index === 1) {
                renderCircles();
            }
        }

        function renderCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (hasBackground) {
                ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#f0f0f0'; // –°–µ—Ä—ã–π —Ñ–æ–Ω, –µ—Å–ª–∏ –Ω–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            circles.forEach(circle => {
                const isVisible = !selectedFilters['–ö—Ä—É–≥'] || circle.id === selectedFilters['–ö—Ä—É–≥'];
                if (isVisible) {
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, 15, 0, 2 * Math.PI);
                    ctx.fillStyle = newCircles.has(circle.id) ? 'red' : 'blue';
                    ctx.fill();
                    ctx.stroke();
                }
            });
        }

        background.onload = () => {
            console.log('–§–æ–Ω –∑–∞–≥—Ä—É–∂–µ–Ω —É—Å–ø–µ—à–Ω–æ!');
            hasBackground = true;
            renderCircles();
        };
        background.onerror = () => {
            console.log('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ–Ω–∞, —Ä–∏—Å—É–µ–º –±–µ–∑ –Ω–µ–≥–æ.');
            hasBackground = false;
            renderCircles();
        };
        background.src = './background.jpg'; // –õ–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª (–ø–æ–ª–æ–∂–∏—Ç–µ background.jpg –≤ –ø–∞–ø–∫—É —Å HTML)

        loadCircles();
        loadCSV();

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        document.getElementById('addCircleBtn').addEventListener('click', () => {
            const x = Math.random() * (canvas.width - 30) + 15;
            const y = Math.random() * (canvas.height - 30) + 15;
            const id = prompt('–í–≤–µ–¥–∏—Ç–µ ID –∫—Ä—É–≥–∞:');
            if (id) {
                circles.push({ x, y, id: String(id) });
                newCircles.add(String(id));
                renderCircles();
            }
        });

        document.getElementById('removeCircleBtn').addEventListener('click', () => {
            const id = prompt('–í–≤–µ–¥–∏—Ç–µ ID –∫—Ä—É–≥–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:');
            if (id) {
                circles = circles.filter(c => c.id !== String(id));
                newCircles.delete(String(id));
                renderCircles();
            }
        });

        document.getElementById('saveChangesBtn').addEventListener('click', () => {
            localStorage.setItem('circles', JSON.stringify(circles));
            alert('–ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!');
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            const dataStr = JSON.stringify(circles, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'circles_export.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('importInput').click();
        });

        document.getElementById('importInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        circles = JSON.parse(event.target.result).map(c => ({
                            ...c,
                            id: String(c.id || '')
                        }));
                        renderCircles();
                        updateFilters();
                    } catch (err) {
                        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ JSON!');
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('switchToUserBtn').addEventListener('click', () => {
            window.location.href = 'user.html';
        });

        document.getElementById('groupSelect').addEventListener('change', (e) => {
            selectedFilters['–°–æ—Ä—Ç'] = e.target.value;
            cascadeFilters('–°–æ—Ä—Ç');
        });

        document.getElementById('subgroupSelect').addEventListener('change', (e) => {
            selectedFilters['–ö—Ä—É–≥'] = e.target.value;
            cascadeFilters('–ö—Ä—É–≥');
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            draggedCircle = circles.find(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedCircle) {
                const rect = canvas.getBoundingClientRect();
                draggedCircle.x = e.clientX - rect.left;
                draggedCircle.y = e.clientY - rect.top;
                renderCircles();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedCircle = null;
        });

        canvas.addEventListener('keydown', (e) => {
            if (e.key === 'Delete') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const index = circles.findIndex(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15);
                if (index !== -1) {
                    newCircles.delete(circles[index].id);
                    circles.splice(index, 1);
                    renderCircles();
                }
            }
        });

        canvas.tabIndex = 0; // –î–ª—è —Ñ–æ–∫—É—Å–∞ –Ω–∞ canvas
    </script>
</body>
</html>
