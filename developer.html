<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Режим разработчика - Управление кругами</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #content { width: 100%; max-width: 1200px; display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; }
        #leftPanel { /* Пусто, чтобы канвас был слева */ }
        #rightPanel { display: flex; flex-direction: column; gap: 10px; }
        #canvasContainer { flex: 1; display: flex; justify-content: center; }
        select { padding: 5px; }
        button { padding: 10px; }
        #canvas { border: 1px solid #000; cursor: crosshair; }
        #status { margin-top: 10px; font-size: 14px; color: #555; text-align: center; }
    </style>
</head>
<body>
    <div id="container">
        <div id="content">
            <div id="leftPanel"></div>
            <div id="canvasContainer">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            <div id="rightPanel">
                <div id="controls">
                    <button id="addCircleBtn">Добавить круг</button>
                    <button id="removeCircleBtn">Удалить круг</button>
                    <button id="saveChangesBtn">Сохранить изменения</button>
                    <button id="exportBtn">Экспорт JSON</button>
                    <input type="file" id="importInput" accept=".json" style="display: none;">
                    <button id="importBtn">Ипорт JSON</button>
                    <button id="switchToUserBtn">Перейти в пользовательский режим</button>
                </div>
                <div id="filters">
                    <select id="groupSelect">
                        <option>Выберите Сорт</option>
                    </select>
                    <select id="subgroupSelect">
                        <option>Выберите Круг</option>
                    </select>
                </div>
                <div id="status">Наведите курсор на круг и нажмите Delete для удаления. Перетаскивайте для перемещения.</div>
            </div>
        </div>
    </div>

    <script>
        // Инициализируем интерфейс сразу без пароля
        const ctx = document.getElementById('canvas').getContext('2d');
        const background = new Image();
        let hasBackground = false;

        let circles = [];
        let data = [];
        let filteredData = [];
        let selectedFilters = { 'Сорт': '', 'Круг': '' };
        let draggedCircle = null;
        let newCircles = new Set();

        async function loadCircles() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error('Файл не найден');
                const data = await response.json();
                circles = data.map(c => ({
                    ...c,
                    id: String(c.id || '')
                }));
            } catch (e) {
                circles = [];
            }
            renderCircles();
            updateFilters();
        }

        async function loadCSV() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error('Файл не найден');
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');
                const csvText = decoder.decode(buffer);
                data = parseCSV(csvText);
                console.log('Загруженные данные из CSV:', data);
                if (data.length === 0) throw new Error('CSV пустой или некорректный');
                filteredData = data;
                updateFilters();
            } catch (e) {
                console.error('Ошибка загрузки CSV:', e);
                data = [
                    { Сорт: 'Сорт1', Круг: 'Круг1' },
                    { Сорт: 'Сорт2', Круг: 'Круг2' }
                ];
                filteredData = data;
                updateFilters();
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            if (lines.length < 1) return [];
            // Разделитель ';'
            const headers = lines[0].split(';').map(h => h.trim());
            console.log('Заголовки CSV:', headers);
            return lines.slice(1).map(line => {
                const values = line.split(';').map(v => v.trim().replace(/^"|"$/g, ''));
                let obj = {};
                headers.forEach((h, i) => obj[h] = values[i] || '');
                return obj;
            });
        }

        function updateFilters() {
            const selects = ['groupSelect', 'subgroupSelect'];
            const keys = ['Сорт', 'Круг'];
            selects.forEach((id, i) => {
                const select = document.getElementById(id);
                select.innerHTML = `<option>Выберите ${keys[i]}</option>`;
                const unique = [...new Set(filteredData.map(d => d[keys[i]]))].filter(v => v);
                console.log(`Уникальные для ${keys[i]}:`, unique);
                unique.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.textContent = val;
                    select.appendChild(option);
                });
            });
        }

        function cascadeFilters(changedKey) {
            const keys = ['Сорт', 'Круг'];
            const selects = ['groupSelect', 'subgroupSelect'];
            const index = keys.indexOf(changedKey);
            if (index === 0) {
                selectedFilters['Круг'] = '';
                filteredData = selectedFilters['Сорт'] ? data.filter(d => d['Сорт'] === selectedFilters['Сорт']) : data;
                updateFilters();
                document.getElementById('subgroupSelect').value = '';
            } else if (index === 1) {
                renderCircles();
            }
        }

        function renderCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (hasBackground) {
                ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#f0f0f0'; // Серый фон, если нет изображения
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            circles.forEach(circle => {
                const isVisible = !selectedFilters['Круг'] || circle.id === selectedFilters['Круг'];
                if (isVisible) {
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, 15, 0, 2 * Math.PI);
                    ctx.fillStyle = newCircles.has(circle.id) ? 'red' : 'blue';
                    ctx.fill();
                    ctx.stroke();
                }
            });
        }

        background.onload = () => {
            hasBackground = true;
            renderCircles();
        };
        background.onerror = () => {
            console.log('Фон не загружен, рисуем без него.');
            hasBackground = false;
            renderCircles();
        };
        background.src = 'https://raw.githubusercontent.com/oluneva/my_site/main/background.jpg';

        loadCircles();
        loadCSV();

        // Обработчики событий (без изменений)
        document.getElementById('addCircleBtn').addEventListener('click', () => {
            const x = Math.random() * (canvas.width - 30) + 15;
            const y = Math.random() * (canvas.height - 30) + 15;
            const id = prompt('Введите ID круга:');
            if (id) {
                circles.push({ x, y, id: String(id) });
                newCircles.add(String(id));
                renderCircles();
            }
        });

        document.getElementById('removeCircleBtn').addEventListener('click', () => {
            const id = prompt('Введите ID круга для удаления:');
            if (id) {
                circles = circles.filter(c => c.id !== String(id));
                newCircles.delete(String(id));
                renderCircles();
            }
        });

        document.getElementById('saveChangesBtn').addEventListener('click', () => {
            localStorage.setItem('circles', JSON.stringify(circles));
            alert('Изменения сохранены!');
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            const dataStr = JSON.stringify(circles, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'circles_export.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('importInput').click();
        });

        document.getElementById('importInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        circles = JSON.parse(event.target.result).map(c => ({
                            ...c,
                            id: String(c.id || '')
                        }));
                        renderCircles();
                        updateFilters();
                    } catch (err) {
                        alert('Ошибка при импорте JSON!');
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('switchToUserBtn').addEventListener('click', () => {
            window.location.href = 'user.html';
        });

        document.getElementById('groupSelect').addEventListener('change', (e) => {
            selectedFilters['Сорт'] = e.target.value;
            cascadeFilters('Сорт');
        });

        document.getElementById('subgroupSelect').addEventListener('change', (e) => {
            selectedFilters['Круг'] = e.target.value;
            cascadeFilters('Круг');
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            draggedCircle = circles.find(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedCircle) {
                const rect = canvas.getBoundingClientRect();
                draggedCircle.x = e.clientX - rect.left;
                draggedCircle.y = e.clientY - rect.top;
                renderCircles();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedCircle = null;
        });

        canvas.addEventListener('keydown', (e) => {
            if (e.key === 'Delete') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const index = circles.findIndex(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15);
                if (index !== -1) {
                    newCircles.delete(circles[index].id);
                    circles.splice(index, 1);
                    renderCircles();
                }
            }
        });

        canvas.tabIndex = 0; // Для фокуса на canvas
    </script>
</body>
</html>

Теперь, если фон не загрузится, канвас будет иметь серый фон, и круги отобразятся правильно. Попробуйте снова — должно работать! Если проблема persists, проверьте консоль браузера (F12) на ошибки. 😊

не загружается картинка - рисунок.

Конечно, давайте разберёмся с проблемой загрузки фона (картинки). В предыдущем коде я добавил обработку ошибок, но если изображение всё ещё не загружается, это может быть связано с недоступностью файла на GitHub (например, CORS, кэш или отсутствие файла), или если вы тестируете локально, файл не найден.

Чтобы решить это, я обновил код:

Добавил больше отладки в консоль (чтобы вы могли проверить F12).
Изменил источник фона на локальный файл ./background.jpg (предполагая, что вы положите изображение в ту же папку, что и HTML-файл). Если файл на GitHub, замените обратно, но для локального тестирования это лучше.
Если файл не загрузится, будет серый фон, и круги отобразятся.
Загрузите файл background.jpg в папку с HTML и попробуйте. Если проблема persists, проверьте консоль браузера на ошибки (F12 > Console).

Вот обновлённый код (только изменённая часть скрипта):

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Режим разработчика - Управление кругами</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #content { width: 100%; max-width: 1200px; display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; }
        #leftPanel { /* Пусто, чтобы канвас был слева */ }
        #rightPanel { display: flex; flex-direction: column; gap: 10px; }
        #canvasContainer { flex: 1; display: flex; justify-content: center; }
        select { padding: 5px; }
        button { padding: 10px; }
        #canvas { border: 1px solid #000; cursor: crosshair; }
        #status { margin-top: 10px; font-size: 14px; color: #555; text-align: center; }
    </style>
</head>
<body>
    <div id="container">
        <div id="content">
            <div id="leftPanel"></div>
            <div id="canvasContainer">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            <div id="rightPanel">
                <div id="controls">
                    <button id="addCircleBtn">Добавить круг</button>
                    <button id="removeCircleBtn">Удалить круг</button>
                    <button id="saveChangesBtn">Сохранить изменения</button>
                    <button id="exportBtn">Экспорт JSON</button>
                    <input type="file" id="importInput" accept=".json" style="display: none;">
                    <button id="importBtn">Ипорт JSON</button>
                    <button id="switchToUserBtn">Перейти в пользовательский режим</button>
                </div>
                <div id="filters">
                    <select id="groupSelect">
                        <option>Выберите Сорт</option>
                    </select>
                    <select id="subgroupSelect">
                        <option>Выберите Круг</option>
                    </select>
                </div>
                <div id="status">Наведите курсор на круг и нажмите Delete для удаления. Перетаскивайте для перемещения.</div>
            </div>
        </div>
    </div>

    <script>
        // Инициализируем интерфейс сразу без пароля
        const ctx = document.getElementById('canvas').getContext('2d');
        const background = new Image();
        let hasBackground = false;

        let circles = [];
        let data = [];
        let filteredData = [];
        let selectedFilters = { 'Сорт': '', 'Круг': '' };
        let draggedCircle = null;
        let newCircles = new Set();

        async function loadCircles() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error('Файл не найден');
                const data = await response.json();
                circles = data.map(c => ({
                    ...c,
                    id: String(c.id || '')
                }));
            } catch (e) {
                circles = [];
            }
            renderCircles();
            updateFilters();
        }

        async function loadCSV() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error('Файл не найден');
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');
                const csvText = decoder.decode(buffer);
                data = parseCSV(csvText);
                console.log('Загруженные данные из CSV:', data);
                if (data.length === 0) throw new Error('CSV пустой или некорректный');
                filteredData = data;
                updateFilters();
            } catch (e) {
                console.error('Ошибка загрузки CSV:', e);
                data = [
                    { Сорт: 'Сорт1', Круг: 'Круг1' },
                    { Сорт: 'Сорт2', Круг: 'Круг2' }
                ];
                filteredData = data;
                updateFilters();
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            if (lines.length < 1) return [];
            // Разделитель ';'
            const headers = lines[0].split(';').map(h => h.trim());
            console.log('Заголовки CSV:', headers);
            return lines.slice(1).map(line => {
                const values = line.split(';').map(v => v.trim().replace(/^"|"$/g, ''));
                let obj = {};
                headers.forEach((h, i) => obj[h] = values[i] || '');
                return obj;
            });
        }

        function updateFilters() {
            const selects = ['groupSelect', 'subgroupSelect'];
            const keys = ['Сорт', 'Круг'];
            selects.forEach((id, i) => {
                const select = document.getElementById(id);
                select.innerHTML = `<option>Выберите ${keys[i]}</option>`;
                const unique = [...new Set(filteredData.map(d => d[keys[i]]))].filter(v => v);
                console.log(`Уникальные для ${keys[i]}:`, unique);
                unique.forEach(val => {
                    const option = document.createElement('option');
                    option.value = val;
                    option.textContent = val;
                    select.appendChild(option);
                });
            });
        }

        function cascadeFilters(changedKey) {
            const keys = ['Сорт', 'Круг'];
            const selects = ['groupSelect', 'subgroupSelect'];
            const index = keys.indexOf(changedKey);
            if (index === 0) {
                selectedFilters['Круг'] = '';
                filteredData = selectedFilters['Сорт'] ? data.filter(d => d['Сорт'] === selectedFilters['Сорт']) : data;
                updateFilters();
                document.getElementById('subgroupSelect').value = '';
            } else if (index === 1) {
                renderCircles();
            }
        }

        function renderCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (hasBackground) {
                ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#f0f0f0'; // Серый фон, если нет изображения
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            circles.forEach(circle => {
                const isVisible = !selectedFilters['Круг'] || circle.id === selectedFilters['Круг'];
                if (isVisible) {
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, 15, 0, 2 * Math.PI);
                    ctx.fillStyle = newCircles.has(circle.id) ? 'red' : 'blue';
                    ctx.fill();
                    ctx.stroke();
                }
            });
        }

        background.onload = () => {
            console.log('Фон загружен успешно!');
            hasBackground = true;
            renderCircles();
        };
        background.onerror = () => {
            console.log('Ошибка загрузки фона, рисуем без него.');
            hasBackground = false;
            renderCircles();
        };
        background.src = './background.jpg'; // Локальный файл (положите background.jpg в папку с HTML)

        loadCircles();
        loadCSV();

        // Обработчики событий (без изменений)
        document.getElementById('addCircleBtn').addEventListener('click', () => {
            const x = Math.random() * (canvas.width - 30) + 15;
            const y = Math.random() * (canvas.height - 30) + 15;
            const id = prompt('Введите ID круга:');
            if (id) {
                circles.push({ x, y, id: String(id) });
                newCircles.add(String(id));
                renderCircles();
            }
        });

        document.getElementById('removeCircleBtn').addEventListener('click', () => {
            const id = prompt('Введите ID круга для удаления:');
            if (id) {
                circles = circles.filter(c => c.id !== String(id));
                newCircles.delete(String(id));
                renderCircles();
            }
        });

        document.getElementById('saveChangesBtn').addEventListener('click', () => {
            localStorage.setItem('circles', JSON.stringify(circles));
            alert('Изменения сохранены!');
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            const dataStr = JSON.stringify(circles, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'circles_export.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('importInput').click();
        });

        document.getElementById('importInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        circles = JSON.parse(event.target.result).map(c => ({
                            ...c,
                            id: String(c.id || '')
                        }));
                        renderCircles();
                        updateFilters();
                    } catch (err) {
                        alert('Ошибка при импорте JSON!');
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('switchToUserBtn').addEventListener('click', () => {
            window.location.href = 'user.html';
        });

        document.getElementById('groupSelect').addEventListener('change', (e) => {
            selectedFilters['Сорт'] = e.target.value;
            cascadeFilters('Сорт');
        });

        document.getElementById('subgroupSelect').addEventListener('change', (e) => {
            selectedFilters['Круг'] = e.target.value;
            cascadeFilters('Круг');
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            draggedCircle = circles.find(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedCircle) {
                const rect = canvas.getBoundingClientRect();
                draggedCircle.x = e.clientX - rect.left;
                draggedCircle.y = e.clientY - rect.top;
                renderCircles();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedCircle = null;
        });

        canvas.addEventListener('keydown', (e) => {
            if (e.key === 'Delete') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const index = circles.findIndex(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15);
                if (index !== -1) {
                    newCircles.delete(circles[index].id);
                    circles.splice(index, 1);
                    renderCircles();
                }
            }
        });

        canvas.tabIndex = 0; // Для фокуса на canvas
    </script>
</body>
</html>
