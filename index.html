
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Пользовательский режим - Просмотр кругов</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #filters { margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        select { padding: 5px; }
        #subgroupSelect { display: none; } /* Скрываем селектор Круга по умолчанию */
        #controls { margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        button { padding: 10px; }
        #canvas { border: 1px solid #000; }
        #status { margin-top: 10px; font-size: 14px; color: #555; }
    </style>
</head>
<body>
    <div id="container">
        <h1 id="modeTitle">Пользовательский режим</h1>
        <div id="filters">
            <select id="classSelect"><option>Не выбрано</option></select>
            <select id="subclassSelect"><option>Не выбрано</option></select>
            <select id="typeSelect"><option>Не выбрано</option></select>
            <select id="subtypeSelect"><option>Не выбрано</option></select>
            <select id="groupSelect"><option>Не выбрано</option></select>
            <select id="subgroupSelect"><option>Не выбрано</option></select> <!-- Скрыт в пользовательском режиме -->
        </div>
        <div id="controls">
            <button id="findPlantBtn">Найти растение</button>
            <button id="switchToDeveloperBtn">Перейти в режим разработчика</button>
        </div>
        <canvas id="canvas" width="800" height="600"></canvas>
        <div id="status">Загрузка данных...</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const background = new Image();
        background.src = 'https://github.com/oluneva/my_site/raw/main/my-image.jpg';

        let circles = [];
        let data = [];
        let selectedFilters = { class: '', subclass: '', type: '', subtype: '', group: '', subgroup: '' };
        let blinkingCircleId = null;
        let blinkInterval = null;
        let isBlinking = false;
        let csvLoaded = false;

        // Функция загрузки кругов из circles_export.json
        async function loadCircles() {
            try {
                console.log('Пытаюсь загрузить circles_export.json...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                circles = await response.json();
                circles = circles.filter(circle => circle && typeof circle.id === 'string' && circle.id.trim() !== '' && typeof circle.x === 'number' && typeof circle.y === 'number');
                if (circles.length === 0) throw new Error('JSON пустой или некорректный');
                console.log('Круги загружены из circles_export.json:', circles.length, 'кругов');
                document.getElementById('status').textContent = `Загружено ${circles.length} кругов.`;
            } catch (e) {
                console.warn('Не удалось загрузить circles_export.json, используем дефолтные круги:', e.message);
                circles = [
                    { id: 'Круг1', x: 100, y: 100 },
                    { id: 'Круг2', x: 200, y: 200 },
                    { id: 'Круг3', x: 300, y: 300 }
                ];
                document.getElementById('status').textContent = 'Используются демо-круги.';
            }
        }

        // Загрузка и парсинг CSV с разделителем ";"
        async function loadCSV() {
            try {
                console.log('Пытаюсь загрузить Plants.csv...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');  // Измените на 'utf-8', если символы искажены
                const csvText = decoder.decode(buffer);
                console.log('Сырой текст CSV (первые 500 символов):', csvText.substring(0, 500));

                // Парсинг с разделителем ";"
                const rows = csvText.split('\n').filter(row => row.trim() !== '');
                if (rows.length < 2) throw new Error('CSV содержит менее 2 строк (заголовки + данные)');
                const headers = rows[0].split(';').map(h => h.replace(/^"|"$/g, '').trim());
                console.log('Заголовки:', headers);
                if (headers.length !== 7 || !headers.includes('Класс') || !headers.includes('Круг') || !headers.includes('Однозначно')) {
                    throw new Error('Заголовки CSV не соответствуют ожидаемым: ["Класс", "Семейство", "Род", "Вид", "Сорт", "Круг", "Однозначно"]');
                }

                data = rows.slice(1).map(row => {
                    const cells = row.split(';').map(cell => cell.replace(/^"|"$/g, '').trim());
                    if (cells.length !== 7) return null;
                    return {
                        class: cells[0],     // Класс
                        subclass: cells[1],  // Семейство
                        type: cells[2],      // Род
                        subtype: cells[3],   // Вид
                        group: cells[4],     // Сорт
                        subgroup: cells[5],  // Круг
                        unique: cells[6]     // Однозначно (скрытое поле)
                    };
                }).filter(item => item && item.class && item.subgroup && item.unique);
                console.log('Данные загружены из CSV:', data.length, 'записей');
                csvLoaded = true;
                document.getElementById('status').textContent += ' Данные фильтров загружены.';
            } catch (e) {
                console.warn('Ошибка загрузки/парсинга CSV, используем демо-данные для фильтров:', e.message);
                data = [
                    { class: 'Класс1', subclass: 'Семейство1', type: 'Род1', subtype: 'Вид1', group: 'Сорт1', subgroup: 'Круг1', unique: 'Уник1' },
                    { class: 'Класс1', subclass: 'Семейство1', type: 'Род1', subtype: 'Вид1', group: 'Сорт1', subgroup: 'Круг2', unique: 'Уник2' },  // Для теста
                    { class: 'Класс2', subclass: 'Семейство2', type: 'Род2', subtype: 'Вид2', group: 'Сорт2', subgroup: 'Круг3', unique: 'Уник3' }
                ];
                document.getElementById('status').textContent += ' Используются демо-данные для фильтров.';
            }
        }

        // Заполнение фильтров
        function populateFilters() {
            const classSelect = document.getElementById('classSelect');
            const subclassSelect = document.getElementById('subclassSelect');
            const typeSelect = document.getElementById('typeSelect');
            const subtypeSelect = document.getElementById('subtypeSelect');
            const groupSelect = document.getElementById('groupSelect');
            const subgroupSelect = document.getElementById('subgroupSelect');

            // Функция для обновления всех фильтров на основе текущих selectedFilters
            function updateAllFilters() {
                // Фильтруем данные на основе выбранных фильтров (только если выбрано что-то кроме пустой строки)
                const filteredData = data.filter(d => {
                    return (!selectedFilters.class || d.class === selectedFilters.class) &&
                           (!selectedFilters.subclass || d.subclass === selectedFilters.subclass) &&
                           (!selectedFilters.type || d.type === selectedFilters.type) &&
                           (!selectedFilters.subtype || d.subtype === selectedFilters.subtype) &&
                           (!selectedFilters.group || d.group === selectedFilters.group) &&
                           (!selectedFilters.subgroup || d.subgroup === selectedFilters.subgroup);
                });

                // Обновляем каждый селект
                const classes = [...new Set(filteredData.map(d => d.class))].sort();
                classSelect.innerHTML = '<option value="">Не выбрано</option>' + classes.map(c => `<option value="${c}">${c}</option>`).join('');
                classSelect.value = selectedFilters.class;

                const subclasses = [...new Set(filteredData.map(d => d.subclass))].sort();
                subclassSelect.innerHTML = '<option value="">Не выбрано</option>' + subclasses.map(c => `<option value="${c}">${c}</option>`).join('');
                subclassSelect.value = selectedFilters.subclass;

                const types = [...new Set(filteredData.map(d => d.type))].sort();
                typeSelect.innerHTML = '<option value="">Не выбрано</option>' + types.map(c => `<option value="${c}">${c}</option>`).join('');
                typeSelect.value = selectedFilters.type;

                const subtypes = [...new Set(filteredData.map(d => d.subtype))].sort();
                subtypeSelect.innerHTML = '<option value="">Не выбрано</option>' + subtypes.map(c => `<option value="${c}">${c}</option>`).join('');
                subtypeSelect.value = selectedFilters.subtype;

                const groups = [...new Set(filteredData.map(d => d.group))].sort();
                groupSelect.innerHTML = '<option value="">Не выбрано</option>' + groups.map(c => `<option value="${c}">${c}</option>`).join('');
                groupSelect.value = selectedFilters.group;

                const subgroups = [...new Set(filteredData.map(d => d.subgroup))].sort();
                subgroupSelect.innerHTML = '<option value="">Не выбрано</option>' + subgroups.map(c => `<option value="${c}">${c}</option>`).join('');
                subgroupSelect.value = selectedFilters.subgroup;
            }

            // Изначально все фильтры на "Не выбрано", показываем все
            updateAllFilters();

            // Обработчики изменений для каждого селекта
            classSelect.addEventListener('change', () => {
                selectedFilters.class = classSelect.value;
                updateAllFilters();
            });

            subclassSelect.addEventListener('change', () => {
                selectedFilters.subclass = subclassSelect.value;
                updateAllFilters();
            });

            typeSelect.addEventListener('change', () => {
                selectedFilters.type = typeSelect.value;
                updateAllFilters();
            });

            subtypeSelect.addEventListener('change', () => {
                selectedFilters.subtype = subtypeSelect.value;
                updateAllFilters();
            });

            groupSelect.addEventListener('change', () => {
                selectedFilters.group = groupSelect.value;
                updateAllFilters();
            });

            subgroupSelect.addEventListener('change', () => {
                selectedFilters.subgroup = subgroupSelect.value;
                updateAllFilters();
            });
        }

        // Рендеринг кругов (всегда отображаются)
        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (background.complete) {
                ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            }
            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, 7, 0, 2 * Math.PI);  // Радиус уменьшен в ~3 раза (20 / 3 ≈ 6.67, округлено до 7)
                if (isBlinking && blinkingCircleId === circle.id) {
                    ctx.fillStyle = 'red';
                } else {
                    ctx.fillStyle = 'rgba(0, 128, 0, 0.5)';
                }
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.stroke();
                // Названия кругов убраны
            });
        }

        // Мигание круга
        function blinkCircle(id) {
            if (isBlinking) {
                clearInterval(blinkInterval);
                isBlinking = false;
            }
            const circle = circles.find(c => c.id === id);
            if (!circle) {
                document.getElementById('status').textContent = 'Круг с таким ID не найден.';
                return;
            }
            blinkingCircleId = id;
            isBlinking = true;
            let blinkCount = 0;
            blinkInterval = setInterval(() => {
                drawCircles();
                blinkCount++;
                if (blinkCount >= 6) {  // 3 секунды (6 раз по 500мс)
                    clearInterval(blinkInterval);
                    isBlinking = false;
                    blinkingCircleId = null;
                    drawCircles();
                }
            }, 500);
        }

        // Инициализация
        async function init() {
            await Promise.all([loadCircles(), loadCSV()]);
            populateFilters();
            drawCircles();
            background.onload = drawCircles;
        }

        init();

        // Кнопка "Найти растение"
        document.getElementById('findPlantBtn').addEventListener('click', () => {
            if (!selectedFilters.group) {
                document.getElementById('status').textContent = 'Сначала выберите Сорт в фильтре.';
                return;
            }
            // Найти значение в поле "Однозначно" по выбранному group
            const matchingData = data.find(d => d.group === selectedFilters.group);
            if (!matchingData || !matchingData.unique) {
                document.getElementById('status').textContent = 'Не найдено соответствующее значение для поиска.';
                return;
            }
            blinkCircle(matchingData.unique);
        });

        // Кнопка перехода в режим разработчика - перенаправление на developer.html
        document.getElementById('switchToDeveloperBtn').addEventListener('click', () => {
            window.location.href = 'developer.html';
        });
    </script>
</body>
</html>
Найти еще

Изменения в пользовательском режиме:
Парсинг CSV теперь ожидает 7 столбцов, включая "Однозначно".
Добавлено поле unique в объект данных.
В findPlantBtn: Теперь проверяется выбор "Сорт" (group), затем ищется соответствующее unique по этому group, и мигает круг с ID = unique.
Теперь код для developer.html (с аналогичными изменениями):

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Режим разработчика - Редактирование кругов</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #filters { margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        select { padding: 5px; }
        #controls { margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        button { padding: 10px; }
        #canvas { border: 1px solid #000; cursor: crosshair; }
        #status { margin-top: 10px; font-size: 14px; color: #555; }
        #editorControls { margin-bottom: 10px; display: flex; gap: 10px; }
        input { padding: 5px; }
    </style>
</head>
<body>
    <div id="container">
        <h1>Режим разработчика</h1>
        <div id="filters">
            <select id="classSelect"><option>Не выбрано</option></select>
            <select id="subclassSelect"><option>Не выбрано</option></select>
            <select id="typeSelect"><option>Не выбрано</option></select>
            <select id="subtypeSelect"><option>Не выбрано</option></select>
            <select id="groupSelect"><option>Не выбрано</option></select>
            <select id="subgroupSelect"><option>Не выбрано</option></select>
        </div>
        <div id="controls">
            <button id="findPlantBtn">Найти растение</button>
            <button id="switchToUserBtn">Перейти в пользовательский режим</button>
        </div>
        <div id="editorControls">
            <button id="addCircleBtn">Добавить круг</button>
            <button id="deleteCircleBtn">Удалить круг</button>
            <input type="text" id="circleIdInput" placeholder="ID круга">
            <button id="saveCirclesBtn">Сохранить круги</button>
        </div>
        <canvas id="canvas" width="800" height="600"></canvas>
        <div id="status">Загрузка данных...</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const background = new Image();
        background.src = 'https://github.com/oluneva/my_site/raw/main/my-image.jpg';

        let circles = [];
        let data = [];
        let selectedFilters = { class: '', subclass: '', type: '', subtype: '', group: '', subgroup: '' };
        let blinkingCircleId = null;
        let blinkInterval = null;
        let isBlinking = false;
        let csvLoaded = false;
        let selectedCircle = null; // Для редактирования

        // Функция загрузки кругов из circles_export.json
        async function loadCircles() {
            try {
                console.log('Пытаюсь загрузить circles_export.json...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                circles = await response.json();
                circles = circles.filter(circle => circle && typeof circle.id === 'string' && circle.id.trim() !== '' && typeof circle.x === 'number' && typeof circle.y === 'number');
                if (circles.length === 0) throw new Error('JSON пустой или некорректный');
                console.log('Круги загружены из circles_export.json:', circles.length, 'кругов');
                document.getElementById('status').textContent = `Загружено ${circles.length} кругов.`;
            } catch (e) {
                console.warn('Не удалось загрузить circles_export.json, используем дефолтные круги:', e.message);
                circles = [
                    { id: 'Круг1', x: 100, y: 100 },
                    { id: 'Круг2', x: 200, y: 200 },
                    { id: 'Круг3', x: 300, y: 300 }
                ];
                document.getElementById('status').textContent = 'Используются демо-круги.';
            }
        }

        // Загрузка и парсинг CSV с разделителем ";"
        async function loadCSV() {
            try {
                console.log('Пытаюсь загрузить Plants.csv...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');  // Измените на 'utf-8', если символы искажены
                const csvText = decoder.decode(buffer);
                console.log('Сырой текст CSV (первые 500 символов):', csvText.substring(0, 500));

                // Парсинг с разделителем ";"
                const rows = csvText.split('\n').filter(row => row.trim() !== '');
                if (rows.length < 2) throw new Error('CSV содержит менее 2 строк (заголовки + данные)');
                const headers = rows[0].split(';').map(h => h.replace(/^"|"$/g, '').trim());
                console.log('Заголовки:', headers);
                if (headers.length !== 7 || !headers.includes('Класс') || !headers.includes('Круг') || !headers.includes('Однозначно')) {
                    throw new Error('Заголовки CSV не соответствуют ожидаемым: ["Класс", "Семейство", "Род", "Вид", "Сорт", "Круг", "Однозначно"]');
                }

                data = rows.slice(1).map(row => {
                    const cells = row.split(';').map(cell => cell.replace(/^"|"$/g, '').trim());
                    if (cells.length !== 7) return null;
                    return {
                        class: cells[0],     // Класс
                        subclass: cells[1],  // Семейство
                        type: cells[2],      // Род
                        subtype: cells[3],   // Вид
                        group: cells[4],     // Сорт
                        subgroup: cells[5],  // Круг
                        unique: cells[6]     // Однозначно (скрытое поле)
                    };
                }).filter(item => item && item.class && item.subgroup && item.unique);
                console.log('Данные загружены из CSV:', data.length, 'записей');
                csvLoaded = true;
                document.getElementById('status').textContent += ' Данные фильтров загружены.';
            } catch (e) {
                console.warn('Ошибка загрузки/парсинга CSV, используем демо-данные для фильтров:', e.message);
                data = [
                    { class: 'Класс1', subclass: 'Семейство1', type: 'Род1', subtype: 'Вид1', group: 'Сорт1', subgroup: 'Круг1', unique: 'Уник1' },
                    { class: 'Класс1', subclass: 'Семейство1', type: 'Род1', subtype: 'Вид1', group: 'Сорт1', subgroup: 'Круг2', unique: 'Уник2' },  // Для теста
                    { class: 'Класс2', subclass: 'Семейство2', type: 'Род2', subtype: 'Вид2', group: 'Сорт2', subgroup: 'Круг3', unique: 'Уник3' }
                ];
                document.getElementById('status').textContent += ' Используются демо-данные для фильтров.';
            }
        }

        // Заполнение фильтров (аналогично пользовательскому режиму)
        function populateFilters() {
            const classSelect = document.getElementById('classSelect');
            const subclassSelect = document.getElementById('subclassSelect');
            const typeSelect = document.getElementById('typeSelect');
            const subtypeSelect = document.getElementById('subtypeSelect');
            const groupSelect = document.getElementById('groupSelect');
            const subgroupSelect = document.getElementById('subgroupSelect');

            function updateAllFilters() {
                const filteredData = data.filter(d => {
                    return (!selectedFilters.class || d.class === selectedFilters.class) &&
                           (!selectedFilters.subclass || d.subclass === selectedFilters.subclass) &&
                           (!selectedFilters.type || d.type === selectedFilters.type) &&
                           (!selectedFilters.subtype || d.subtype === selectedFilters.subtype) &&
                           (!selectedFilters.group || d.group === selectedFilters.group) &&
                           (!selectedFilters.subgroup || d.subgroup === selectedFilters.subgroup);
                });

                const classes = [...new Set(filteredData.map(d => d.class))].sort();
                classSelect.innerHTML = '<option value="">Не выбрано</option>' + classes.map(c => `<option value="${c}">${c}</option>`).join('');
                classSelect.value = selectedFilters.class;

                const subclasses = [...new Set(filteredData.map(d => d.subclass))].sort();
                subclassSelect.innerHTML = '<option value="">Не выбрано</option>' + subclasses.map(c => `<option value="${c}">${c}</option>`).join('');
                subclassSelect.value = selectedFilters.subclass;

                const types = [...new Set(filteredData.map(d => d.type))].sort();
                typeSelect.innerHTML = '<option value="">Не выбрано</option>' + types.map(c => `<option value="${c}">${c}</option>`).join('');
                typeSelect.value = selectedFilters.type;

                const subtypes = [...new Set(filteredData.map(d => d.subtype))].sort();
                subtypeSelect.innerHTML = '<option value="">Не выбрано</option>' + subtypes.map(c => `<option value="${c}">${c}</option>`).join('');
                subtypeSelect.value = selectedFilters.subtype;

                const groups = [...new Set(filteredData.map(d => d.group))].sort();
                groupSelect.innerHTML = '<option value="">Не выбрано</option>' + groups.map(c => `<option value="${c}">${c}</option>`).join('');
                groupSelect.value = selectedFilters.group;

                const subgroups = [...new Set(filteredData.map(d => d.subgroup))].sort();
                subgroupSelect.innerHTML = '<option value="">Не выбрано</option>' + subgroups.map(c => `<option value="${c}">${c}</option>`).join('');
                subgroupSelect.value = selectedFilters.subgroup;
            }

            updateAllFilters();

            classSelect.addEventListener('change', () => {
                selectedFilters.class = classSelect.value;
                updateAllFilters();
            });

            subclassSelect.addEventListener('change', () => {
                selectedFilters.subclass = subclassSelect.value;
                updateAllFilters();
            });

            typeSelect.addEventListener('change', () => {
                selectedFilters.type = typeSelect.value;
                updateAllFilters();
            });

            subtypeSelect.addEventListener('change', () => {
                selectedFilters.subtype = subtypeSelect.value;
                updateAllFilters();
            });

            groupSelect.addEventListener('change', () => {
                selectedFilters.group = groupSelect.value;
                updateAllFilters();
            });

            subgroupSelect.addEventListener('change', () => {
                selectedFilters.subgroup = subgroupSelect.value;
                updateAllFilters();
            });
        }

        // Рендеринг кругов с ID
        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (background.complete) {
                ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            }
            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, 7, 0, 2 * Math.PI);
                if (selectedCircle && selectedCircle.id === circle.id) {
                    ctx.fillStyle = 'blue';
                } else if (isBlinking && blinkingCircleId === circle.id) {
                    ctx.fillStyle = 'red';
                } else {
                    ctx.fillStyle = 'rgba(0, 128, 0, 0.5)';
                }
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.stroke();
                // Показываем ID кругов в режиме разработчика
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.fillText(circle.id, circle.x - ctx.measureText(circle.id).width / 2, circle.y + 20);
            });
        }

        // Мигание круга
        function blinkCircle(id) {
            if (isBlinking) {
                clearInterval(blinkInterval);
                isBlinking = false;
            }
            const circle = circles.find(c => c.id === id);
            if (!circle) {
                document.getElementById('status').textContent = 'Круг с таким ID не найден.';
                return;
            }
            blinkingCircleId = id;
            isBlinking = true;
            let blinkCount = 0;
            blinkInterval = setInterval(() => {
                drawCircles();
                blinkCount++;
                if (blinkCount >= 6) {
                    clearInterval(blinkInterval);
                    isBlinking = false;
                    blinkingCircleId = null;
                    drawCircles();
                }
            }, 500);
        }

        // Инициализация
        async function init() {
            await Promise.all([loadCircles(), loadCSV()]);
            populateFilters();
            drawCircles();
            background.onload = drawCircles;
        }

        init();

        // Кнопка "Найти растение"
        document.getElementById('findPlantBtn').addEventListener('click', () => {
            if (!selectedFilters.group) {
                document.getElementById('status').textContent = 'Сначала выберите Сорт в фильтре.';
                return;
            }
            // Найти значение в поле "Однозначно" по выбранному group
            const matchingData = data.find(d => d.group === selectedFilters.group);
            if (!matchingData || !matchingData.unique) {
                document.getElementById('status').textContent = 'Не найдено соответствующее значение для поиска.';
                return;
            }
            blinkCircle(matchingData.unique);
        });

        // Кнопка перехода в пользовательский режим
        document.getElementById('switchToUserBtn').addEventListener('click', () => {
            window.location.href = 'index.html'; // Предполагаем, что пользовательский режим в index.html
        });

        // Функции редактирования кругов
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            selectedCircle = circles.find(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 10);
            if (selectedCircle) {
                document.getElementById('circleIdInput').value = selectedCircle.id;
                document.getElementById('status').textContent = `Выбран круг: ${selectedCircle.id}`;
            } else {
                selectedCircle = null;
                document.getElementById('status').textContent = 'Кликните на круг для выбора.';
            }
            drawCircles();
        });

        document.getElementById('addCircleBtn').addEventListener('click', () => {
            const id = document.getElementById('circleIdInput').value.trim();
            if (!id) {
                document.getElementById('status').textContent = 'Введите ID круга.';
                return;
            }
            if (circles.some(c => c.id === id)) {
                document.getElementById('status').textContent = 'Круг с таким ID уже существует.';
                return;
            }
            circles.push({ id, x: 400, y: 300 }); // Добавляем в центр
            drawCircles();
            document.getElementById('status').textContent = `Круг "${id}" добавлен.`;
        });

        document.getElementById('deleteCircleBtn').addEventListener('click', () => {
            if (!selectedCircle) {
                document.getElementById('status').textContent = 'Сначала выберите круг.';
                return;
            }
            circles = circles.filter(c => c.id !== selectedCircle.id);
            selectedCircle = null;
            drawCircles();
            document.getElementById('status').textContent = 'Круг удален.';
        });

        // Перетаскивание кругов
        let isDragging = false;
        canvas.addEventListener('mousedown', (e) => {
            if (selectedCircle) {
                isDragging = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && selectedCircle) {
                const rect = canvas.getBoundingClientRect();
                selectedCircle.x = e.clientX - rect.left;
                selectedCircle.y = e.clientY - rect.top;
                drawCircles();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Сохранение кругов (в консоль, для демонстрации; в реальности - отправка на сервер)
        document.getElementById('saveCirclesBtn').addEventListener('click', () => {
            console.log('Сохраненные круги:', JSON.stringify(circles, null, 2));
            document.getElementById('status').textContent = 'Круги сохранены (в консоли).';
        });
    </script>
</body>
</html>
