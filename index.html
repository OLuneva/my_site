<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Пользовательский режим - Просмотр кругов</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #77c98c; /* Бледно-зеленый, спокойный фон (Honeydew) */
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            height: 100vh;
        }
        #leftPanel {
            flex: 1.5; /* Левая панель занимает 75% ширины */
            /* Убрал background-image, так как изображение теперь рисуется на канвасе */
            background-color: #77c98c; /* Бледно-зеленый подложка под изображением */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        #canvas {
            max-width: 100%;
            height: auto;
            display: block;
        }
        #rightPanel {
            flex: 0.25; /* Правая панель занимает примерно 12.5% ширины (уменьшена в 2 раза по сравнению с предыдущей версией) */
            background-color: #77c98c; /* Бледно-зеленый, как общий фон */
            padding: 15px; /* Уменьшенный padding */
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Легкая тень для выделения */
            color: black; /* Черный цвет текста для контраста на светлом фоне */
        }
        #filters {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Уменьшенный gap */
        }
        .filter-item {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 3px; /* Уменьшенный margin */
            font-size: 12px; /* Уменьшенный шрифт */
        }
        select {
            padding: 5px; /* Уменьшенный padding */
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px; /* Уменьшенный шрифт */
            background-color: white; /* Белый фон для селекторов */
            color: black; /* Черный текст в селекторах */
        }
        #subgroupItem {
            display: none; /* Скрываем селектор "Круг" в пользовательском режиме */
        }
        button { 
            padding: 10px 20px; /* Уменьшенный padding для кнопки */
            background-color: #808080; /* Серый цвет для кнопки */
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 14px; /* Уменьшенный шрифт */
            font-weight: bold;
            transition: background-color 0.3s ease; 
            align-self: flex-start; /* Выравниваем кнопку по левому краю */
        }
        button:hover { 
            background-color: #696969; /* Более темный серый при наведении */
        }
        button:active { 
            background-color: #555555; /* Еще темнее при нажатии */
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="leftPanel">
            <canvas id="canvas"></canvas>
        </div>
        <div id="rightPanel">
            <div id="filters">
                <div class="filter-item">
                    <label for="classSelect">Класс:</label>
                    <select id="classSelect"><option>Не выбрано</option></select>
                </div>
                <div class="filter-item">
                    <label for="subclassSelect">Семейство:</label>
                    <select id="subclassSelect"><option>Не выбрано</option></select>
                </div>
                <div class="filter-item">
                    <label for="typeSelect">Род:</label>
                    <select id="typeSelect"><option>Не выбрано</option></select>
                </div>
                <div class="filter-item">
                    <label for="subtypeSelect">Вид:</label>
                    <select id="subtypeSelect"><option>Не выбрано</option></select>
                </div>
                <div class="filter-item">
                    <label for="groupSelect">Сорт:</label>
                    <select id="groupSelect"><option>Не выбрано</option></select>
                </div>
                <div class="filter-item" id="subgroupItem">
                    <label for="subgroupSelect">Круг:</label>
                    <select id="subgroupSelect"><option>Не выбрано</option></select>
                </div>
            </div>
            <button id="findPlantBtn">Найти растение</button>
        </div>
    </div>

    <script>
        // Простая проверка пароля при загрузке страницы
        const PASSWORD = 'demo123';  // Замените на свой пароль

        window.onload = function() {
            const enteredPassword = prompt('Введите пароль для доступа к пользовательскому режиму:');
            if (enteredPassword !== PASSWORD) {
                alert('Неверный пароль. Доступ запрещён.');
                document.body.innerHTML = '<h1 style="text-align: center; padding-top: 50px; color: black;">Доступ запрещён</h1>';  // Черный текст на светлом фоне
                return;
            }
            // Если пароль верный, инициализируем сайт
            init();
        };

        let canvas, ctx;  // Глобальные переменные, инициализируем в init()
        let circlesData = [];  // Глобальная переменная для данных кругов
        let img;  // Глобальная переменная для изображения
        let data = [];
        let selectedFilters = { class: '', subclass: '', type: '', subtype: '', group: '' }; // subgroup скрыт, не используется
        let blinkingCircleIds = [];
        let blinkInterval = null;
        let isBlinking = false;
        let blinkState = false;  // Для переключения состояния мигания
        let csvLoaded = false;

        // Функция загрузки кругов из circles_export.json
        async function loadCircles() {
            try {
                console.log('Пытаюсь загрузить circles_export.json...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                circlesData = await response.json();  // Заполняем глобальную переменную
                console.log('Круги загружены из circles_export.json:', circlesData.length, 'кругов');
                if (circlesData.length > 0) {
                    console.log('Примеры координат (x,y):', circlesData.slice(0, 3).map(c => `ID ${c.id}: (${c.x}, ${c.y})`));
                }
                
                // Загрузка изображения и рисование кругов
                await loadImageAndDrawCircles();
            } catch (e) {
                console.error('Ошибка загрузки кругов:', e.message);
            }
        }

        async function loadImageAndDrawCircles() {
            img = new Image();  // Создаем изображение и сохраняем глобально
            
            img.onload = () => {
                console.log('Изображение загружено, рисую...');
                canvas.width = img.width;
                canvas.height = img.height;
                canvas.style.width = '100%';  // Масштабируем канвас под контейнер
                canvas.style.height = 'auto';  // Сохраняем пропорции
                
                ctx.drawImage(img, 0, 0);
                
                // Рисуем круги
                drawCircles();
            };
            
            img.onerror = () => {
                console.error('Ошибка загрузки изображения my-image.jpg');
            };
            
            img.src = 'https://raw.githubusercontent.com/oluneva/my_site/main/my-image.jpg';  // Правильный URL
        }

        function drawCircles() {
            if (!img) return;  // Если изображение не загружено, не рисуем
            ctx.drawImage(img, 0, 0);  // Перерисовываем изображение
            console.log('Рисую', circlesData.length, 'кругов...');
            circlesData.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, 10, 0, 2 * Math.PI);  // Радиус 10px
                if (blinkingCircleIds.includes(circle.id) && isBlinking && blinkState) {
                    ctx.fillStyle = 'red';  // Мигающие круги красные
                } else {
                    ctx.fillStyle = 'green';  // Обычные круги зелёные
                }
                ctx.fill();
            });
            console.log('Круги нарисованы.');
        }

        // Функция загрузки данных из CSV
        async function loadCSV() {
            try {
                console.log('Пытаюсь загрузить Plants.csv...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                // Декодируем как Windows-1251 (CP1251), чтобы корректно прочитать русские буквы
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');  // Для CP1251; если другая кодировка, замените (например, 'iso-8859-5')
                const csvText = decoder.decode(buffer);
                
                data = parseCSV(csvText);
                console.log('CSV загружено:', data.length, 'записей');
                if (data.length > 0) {
                    console.log('Примеры данных:', data.slice(0, 3));
                }
                populateFilters();
                csvLoaded = true;
            } catch (e) {
                console.error('Ошибка загрузки CSV:', e.message);
                alert('Не удалось загрузить данные растений. Проверьте консоль браузера.');
            }
        }

        // Функция парсинга CSV с разделителем ";"
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n').filter(line => line.trim() !== ''); // Убираем пустые строки
            if (lines.length < 2) {
                console.warn('CSV пустой или содержит только заголовки');
                return [];
            }
            const headers = lines[0].split(';').map(h => h.trim());
            console.log('Заголовки CSV:', headers); // Лог заголовков для проверки
            const expectedHeaders = ['Класс', 'Семейство', 'Род', 'Вид', 'Сорт', 'Круг'];
            // Гибкая проверка: если заголовки не точные, но есть похожие, продолжаем
            if (!headers.some(h => h.toLowerCase().includes('класс'))) {
                console.warn('Заголовки CSV не содержат "Класс". Проверьте файл.');
                return [];
            }
            return lines.slice(1).map(line => {
                const values = line.split(';').map(v => v.trim());
                if (values.length !== headers.length) {
                    console.warn('Некорректная строка CSV:', line);
                    return null;
                }
                const row = {};
                headers.forEach((header, index) => {
                    row[header.toLowerCase()] = values[index]; // Ключи в нижнем регистре для удобства
                });
                return row;
            }).filter(row => row !== null);
        }

        // Функция заполнения селекторов
        function populateFilters() {
            if (data.length === 0) return;
            const classSelect = document.getElementById('classSelect');
            const subclassSelect = document.getElementById('subclassSelect');
            const typeSelect = document.getElementById('typeSelect');
            const subtypeSelect = document.getElementById('subtypeSelect');
            const groupSelect = document.getElementById('groupSelect');
            // subgroupSelect скрыт

            const classes = [...new Set(data.map(d => d['класс']).filter(Boolean))];
            const subclasses = [...new Set(data.map(d => d['семейство']).filter(Boolean))];
            const types = [...new Set(data.map(d => d['род']).filter(Boolean))];
            const subtypes = [...new Set(data.map(d => d['вид']).filter(Boolean))];
            const groups = [...new Set(data.map(d => d['сорт']).filter(Boolean))];

            populateSelect(classSelect, classes);
            populateSelect(subclassSelect, subclasses);
            populateSelect(typeSelect, types);
            populateSelect(subtypeSelect, subtypes);
            populateSelect(groupSelect, groups);

            // Обработчики изменения
            classSelect.addEventListener('change', () => { selectedFilters.class = classSelect.value; filterData(); });
            subclassSelect.addEventListener('change', () => { selectedFilters.subclass = subclassSelect.value; filterData(); });
            typeSelect.addEventListener('change', () => { selectedFilters.type = typeSelect.value; filterData(); });
            subtypeSelect.addEventListener('change', () => { selectedFilters.subtype = subtypeSelect.value; filterData(); });
            groupSelect.addEventListener('change', () => { selectedFilters.group = groupSelect.value; filterData(); });
        }

        // Функция заполнения одного селектора
        function populateSelect(select, options) {
            select.innerHTML = '<option>Не выбрано</option>';
            options.sort().forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                select.appendChild(opt);
            });
        }

        // Функция фильтрации данных и поиска кругов
        function filterData() {
            if (!csvLoaded || data.length === 0) {
                console.warn('Данные ещё не загружены');
                return;
            }
            const filtered = data.filter(d => {
                return (!selectedFilters.class || d['класс'] === selectedFilters.class) &&
                       (!selectedFilters.subclass || d['семейство'] === selectedFilters.subclass) &&
                       (!selectedFilters.type || d['род'] === selectedFilters.type) &&
                       (!selectedFilters.subtype || d['вид'] === selectedFilters.subtype) &&
                       (!selectedFilters.group || d['сорт'] === selectedFilters.group);
            });
            console.log('Отфильтрованные данные:', filtered.length);
            blinkingCircleIds = filtered.map(d => d['круг']).filter(id => id && circlesData.some(c => c.id == id));  // Исправлено на circlesData
            console.log('Мигающие круги:', blinkingCircleIds);
            if (blinkingCircleIds.length > 0) {
                startBlinking();
            } else {
                stopBlinking();
            }
        }

        // Функции мигания
        function startBlinking() {
            if (blinkInterval) clearInterval(blinkInterval);
            isBlinking = true;
            blinkState = false;  // Начинаем с обычного состояния
            blinkInterval = setInterval(() => {
                blinkState = !blinkState;
                drawCircles();
            }, 500); // Каждые 500мс
        }

        function stopBlinking() {
            isBlinking = false;
            blinkState = false;  // Возвращаем к обычному
            if (blinkInterval) {
                clearInterval(blinkInterval);
                blinkInterval = null;
            }
            drawCircles(); // Перерисовываем без мигания
        }

        // Кнопка "Найти растение" - фильтрует без subgroup
        document.getElementById('findPlantBtn').addEventListener('click', () => {
            filterData();
        });

        // Инициализация
        async function init() {
            canvas = document.getElementById('canvas');  // Инициализируем здесь, после загрузки DOM
            if (!canvas) {
                console.error('Канвас не найден!');
                alert('Ошибка: канвас не найден. Проверьте HTML.');
                return;
            }
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Не удалось получить контекст 2D для канваса!');
                alert('Ошибка: не удалось инициализировать канвас.');
                return;
            }
            await loadCircles();
            await loadCSV();
        }
    </script>
</body>
</html>
