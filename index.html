<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Пользовательский режим - Просмотр кругов</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #filters { margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        select { padding: 5px; }
        #canvas { border: 1px solid #000; }
        #controls { margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        button { padding: 10px; }
    </style>
</head>
<body>
    <div id="container">
        <h1>Пользовательский режим</h1>
        <div id="filters">
            <select id="classSelect"><option>Выберите Класс</option></select>
            <select id="subclassSelect"><option>Выберите Подкласс</option></select>
            <select id="typeSelect"><option>Выберите Тип</option></select>
            <select id="subtypeSelect"><option>Выберите Подтип</option></select>
            <select id="groupSelect"><option>Выберите Группу</option></select>
            <select id="subgroupSelect"><option>Выберите Круг</option></select>
        </div>
        <canvas id="canvas" width="800" height="600"></canvas>
        <div id="controls">
            <button id="findPlantBtn">Найти растение</button>
            <button id="switchToDeveloperBtn">Перейти в режим разработчика</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const background = new Image();
        background.src = 'https://raw.githubusercontent.com/oluneva/my_site/main/my-plants.jpg'; // Фоновое изображение с GitHub

        let circles = []; // Инициализируем пустым массивом
        let data = []; // Данные из CSV
        let filteredData = [];
        let selectedFilters = { class: '', subclass: '', type: '', subtype: '', group: '', subgroup: '' };
        let blinkingCircleId = null; // ID мигающего круга
        let blinkInterval = null; // Интервал для мигания
        let isBlinking = false; // Флаг мигания

        // Функция загрузки кругов из circles_export.json
        async function loadCircles() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error('Файл circles_export.json не найден');
                circles = await response.json();
                // Фильтрация невалидных элементов (только id, x, y)
                circles = circles.filter(circle => circle && typeof circle.id === 'string' && circle.id.trim() !== '' && typeof circle.x === 'number' && typeof circle.y === 'number');
                if (circles.length === 0) throw new Error('JSON пустой или некорректный');
                console.log('Круги загружены из circles_export.json:', circles.length, 'кругов');
            } catch (e) {
                console.warn('Не удалось загрузить circles_export.json, используем дефолтные круги:', e.message);
                circles = [
                    { id: 'circle_1', x: 100, y: 100 },
                    { id: 'circle_2', x: 200, y: 200 },
                    { id: 'circle_3', x: 300, y: 300 }
                ];
            }
        }

        // Загрузка CSV (асинхронно) - URL с GitHub
        async function loadCSV() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error('Файл не найден');
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');
                const csvText = decoder.decode(buffer);
                data = parseCSV(csvText);
                if (data.length === 0) throw new Error('CSV пустой или некорректный');
                filteredData = data;
                console.log('CSV загружен успешно:', data.length, 'строк');
                updateFilters();
            } catch (e) {
                console.warn('CSV не загружен, используем демо-данные:', e.message);
                data = [
                    { Класс: 'Класс1', Подкласс: 'Подкласс1', Тип: 'Тип1', Подтип: 'Подтип1', Группа: 'Группа1', Подгруппа: 'Подгруппа1' },
                    { Класс: 'Класс2', Подкласс: 'Подкласс2', Тип: 'Тип2', Подтип: 'Подтип2', Группа: 'Группа2', Подгруппа: 'Подгруппа2' }
                ];
                filteredData = data;
                updateFilters();
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            if (lines.length < 1) return [];
            const headers = lines[0].split(',').map(h => h.trim());
            const expectedHeaders = ['Класс', 'Подкласс', 'Тип', 'Подтип', 'Группа', 'Подгруппа'];
            if (!expectedHeaders.every(h => headers.includes(h))) {
                console.warn('Заголовки CSV не совпадают, используем демо-данные');
                return [];
            }
            return lines.slice(1).map(line => {
                const values = line.split(',');
                let obj = {};
                headers.forEach((h, i) => obj[h] = values[i]?.trim() || '');
                return obj;
            }).filter(obj => obj['Класс']); // Фильтр пустых строк
        }

        function updateFilters() {
            const selects = ['classSelect', 'subclassSelect', 'typeSelect', 'subtypeSelect', 'groupSelect', 'subgroupSelect'];
            const keys = ['Класс', 'Подкласс', 'Тип', 'Подтип', 'Группа', 'Подгруппа'];
            selects.forEach((id, i) => {
                const select = document.getElementById(id);
                select.innerHTML = `<option>Выберите ${i < 5 ? keys[i] : 'Круг'}</option>`;
                if (i < 5) {
                    const unique = [...new Set(filteredData.map(d => d[keys[i]]))].filter(v => v);
                    unique.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });
                } else {
                    // Для последнего фильтра: показать ID кругов, соответствующих выбранным фильтрам
                    const matchingCircles = circles.filter(circle => {
                        // Демо-связь: проверка по "type" (замените на реальную, если круги имеют типы)
                        const circleType = circle.type || 'Тип1';
                        return (!selectedFilters.class || circleType.includes(selectedFilters.class)) &&
                               (!selectedFilters.subclass || circleType.includes(selectedFilters.subclass)) &&
                               (!selectedFilters.type || circleType === selectedFilters.type) &&
                               (!selectedFilters.subtype || circleType.includes(selectedFilters.subtype)) &&
                               (!selectedFilters.group || circleType.includes(selectedFilters.group)) &&
                               (!selectedFilters.subgroup || circleType.includes(selectedFilters.subgroup));
                    });
                    matchingCircles.forEach(circle => {
                        const option = document.createElement('option');
                        option.value = circle.id;
                        option.textContent = circle.id;
                        select.appendChild(option);
                    });
                }
            });
        }

        function cascadeFilters(changedKey) {
            const keys = ['Класс', 'Подкласс', 'Тип', 'Подтип', 'Группа', 'Подгруппа'];
            const index = keys.indexOf(changedKey);
            filteredData = data.filter(d => {
                return keys.slice(0, index + 1).every(key => !selectedFilters[key.toLowerCase()] || d[key] === selectedFilters[key.toLowerCase()]);
            });
            updateFilters();
        }

        // Обработчики фильтров
        document.getElementById('classSelect').addEventListener('change', e => { selectedFilters.class = e.target.value; cascadeFilters('Класс'); });
        document.getElementById('subclassSelect').addEventListener('change', e => { selectedFilters.subclass = e.target.value; cascadeFilters('Подкласс'); });
        document.getElementById('typeSelect').addEventListener('change', e => { selectedFilters.type = e.target.value; cascadeFilters('Тип'); });
        document.getElementById('subtypeSelect').addEventListener('change', e => { selectedFilters.subtype = e.target.value; cascadeFilters('Подтип'); });
        document.getElementById('groupSelect').addEventListener('change', e => { selectedFilters.group = e.target.value; cascadeFilters('Группа'); });
        document.getElementById('subgroupSelect').addEventListener('change', e => { selectedFilters.subgroup = e.target.value; cascadeFilters('Подгруппа'); });

        function renderCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            circles.forEach(circle => {
                if (!circle || !circle.id) return;
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, 20, 0, 2 * Math.PI);
                // Все круги зелёные, мигающий — красный при isBlinking
                ctx.fillStyle = (blinkingCircleId === circle.id && isBlinking) ? 'red' : 'green';
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(circle.id, circle.x - 15, circle.y + 5);
            });
        }

        // Кнопка "Найти растение"
        document.getElementById('findPlantBtn').addEventListener('click', () => {
            const selectedCircleId = document.getElementById('subgroupSelect').value;
            if (!selectedCircleId) return;
            blinkingCircleId = selectedCircleId;
            // Остановить предыдущее мигание
            if (blinkInterval) clearInterval(blinkInterval);
            isBlinking = false;
            // Начать мигание
            blinkInterval = setInterval(() => {
                isBlinking = !isBlinking;
                renderCircles();
            }, 500);
        });

        // Переход в режим разработчика
        document.getElementById('switchToDeveloperBtn').addEventListener('click', () => {
            if (blinkInterval) clearInterval(blinkInterval); // Остановить мигание при переходе
            window.location.href = 'developer.html';
        });

        // Инициализация: загрузить круги и CSV асинхронно, рендерить сразу
        (async () => {
            await loadCircles();
            await loadCSV();
            renderCircles();
        })();
        background.onload = renderCircles;
        background.onerror = renderCircles;
    </script>
</body>
</html>
