<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Пользовательский режим - Просмотр кругов</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #filtersAndControls { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-bottom: 20px; }
        .labels-row { display: flex; gap: 10px; justify-content: flex-start; width: 100%; max-width: 800px; }
        .labels-row label { font-weight: bold; flex: 1; text-align: center; }
        .filters-row { display: flex; gap: 10px; justify-content: flex-start; width: 100%; max-width: 800px; align-items: center; }
        .filters-row select { padding: 5px; flex: 1; }
        .filters-row button { padding: 10px; }
        #subgroupGroup { display: none; }
        #canvas { border: 1px solid #000; }
        #status { margin-top: 10px; font-size: 14px; color: #555; }
    </style>
</head>
<body>
    <div id="container">
        <h1 id="modeTitle">Пользовательский режим</h1>
        <div id="filtersAndControls">
            <div class="labels-row">
                <label for="classSelect">Класс</label>
                <label for="subclassSelect">Семейство</label>
                <label for="typeSelect">Род</label>
                <label for="subtypeSelect">Вид</label>
                <label for="groupSelect">Сорт</label>
            </div>
            <div class="filters-row">
                <select id="classSelect"><option>Не выбрано</option></select>
                <select id="subclassSelect"><option>Не выбрано</option></select>
                <select id="typeSelect"><option>Не выбрано</option></select>
                <select id="subtypeSelect"><option>Не выбрано</option></select>
                <select id="groupSelect"><option>Не выбрано</option></select>
                <button id="findPlantBtn">Найти растение</button>
                <button id="switchToDeveloperBtn">Перейти в режим разработчика</button>
            </div>
        </div>
        <canvas id="canvas" width="800" height="600"></canvas>
        <div id="status">Загрузка данных...</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const background = new Image();
        background.src = 'https://github.com/oluneva/my_site/raw/main/my-image.jpg';

        let circles = [];
        let data = [];
        let selectedFilters = { class: '', subclass: '', type: '', subtype: '', group: '' }; // Убрали subgroup из selectedFilters, так как он скрыт
        let blinkingCircleIds = [];
        let blinkInterval = null;
        let isBlinking = false;
        let csvLoaded = false;

        // Функция загрузки кругов из circles_export.json
        async function loadCircles() {
            try {
                console.log('Пытаюсь загрузить circles_export.json...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                circles = await response.json();
                circles = circles.filter(circle => circle && typeof circle.id === 'string' && circle.id.trim() !== '' && typeof circle.x === 'number' && typeof circle.y === 'number');
                if (circles.length === 0) throw new Error('JSON пустой или некорректный');
                console.log('Круги загружены из circles_export.json:', circles.length, 'кругов');
                document.getElementById('status').textContent = `Загружено ${circles.length} кругов.`;
            } catch (e) {
                console.warn('Не удалось загрузить circles_export.json, используем дефолтные круги:', e.message);
                circles = [
                    { id: 'Круг1', x: 100, y: 100 },
                    { id: 'Круг2', x: 200, y: 200 },
                    { id: 'Круг3', x: 300, y: 300 }
                ];
                document.getElementById('status').textContent = 'Используются демо-круги.';
            }
        }

        // Загрузка и парсинг CSV с разделителем ";"
        async function loadCSV() {
            try {
                console.log('Пытаюсь загрузить Plants.csv...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');  // Измените на 'utf-8', если символы искажены
                const csvText = decoder.decode(buffer);
                console.log('Сырой текст CSV (первые 500 символов):', csvText.substring(0, 500));

                // Парсинг с разделителем ";"
                const rows = csvText.split('\n').filter(row => row.trim() !== '');
                if (rows.length < 2) throw new Error('CSV содержит менее 2 строк (заголовки + данные)');
                const headers = rows[0].split(';').map(h => h.replace(/^"|"$/g, '').trim());
                console.log('Заголовки:', headers);
                if (headers.length !== 6 || !headers.includes('Класс') || !headers.includes('Круг')) {
                    throw new Error('Заголовки CSV не соответствуют ожидаемым: ["Класс", "Семейство", "Род", "Вид", "Сорт", "Круг"]');
                }

                data = rows.slice(1).map(row => {
                    const cells = row.split(';').map(cell => cell.replace(/^"|"$/g, '').trim());
                    if (cells.length !== 6) return null;
                    return {
                        class: cells[0],     // Класс
                        subclass: cells[1],  // Семейство
                        type: cells[2],      // Род
                        subtype: cells[3],   // Вид
                        group: cells[4],     // Сорт
                        subgroup: cells[5]   // Круг
                    };
                }).filter(item => item && item.class && item.subgroup);
                console.log('Данные загружены из CSV:', data.length, 'записей');
                csvLoaded = true;
                document.getElementById('status').textContent += ' Данные фильтров загружены.';
            } catch (e) {
                console.warn('Ошибка загрузки/парсинга CSV, используем демо-данные для фильтров:', e.message);
                data = [
                    { class: 'Класс1', subclass: 'Семейство1', type: 'Род1', subtype: 'Вид1', group: 'Сорт1', subgroup: 'Круг1' },
                    { class: 'Класс1', subclass: 'Семейство1', type: 'Род1', subtype: 'Вид1', group: 'Сорт1', subgroup: 'Круг2' },  // Для теста нескольких кругов
                    { class: 'Класс2', subclass: 'Семейство2', type: 'Род2', subtype: 'Вид2', group: 'Сорт2', subgroup: 'Круг3' }
                ];
                document.getElementById('status').textContent += ' Используются демо-данные для фильтров.';
            }
        }

        // Заполнение фильтров
        function populateFilters() {
            const classSelect = document.getElementById('classSelect');
            const subclassSelect = document.getElementById('subclassSelect');
            const typeSelect = document.getElementById('typeSelect');
            const subtypeSelect = document.getElementById('subtypeSelect');
            const groupSelect = document.getElementById('groupSelect');

            // Функция для обновления всех фильтров на основе текущих selectedFilters
            function updateAllFilters() {
                // Фильтруем данные на основе выбранных фильтров (только если выбрано что-то кроме пустой строки)
                const filteredData = data.filter(d => {
                    return (!selectedFilters.class || d.class === selectedFilters.class) &&
                           (!selectedFilters.subclass || d.subclass === selectedFilters.subclass) &&
                           (!selectedFilters.type || d.type === selectedFilters.type) &&
                           (!selectedFilters.subtype || d.subtype === selectedFilters.subtype) &&
                           (!selectedFilters.group || d.group === selectedFilters.group);
                });

                // Обновляем каждый селект
                const classes = [...new Set(filteredData.map(d => d.class))].sort();
                classSelect.innerHTML = '<option value="">Не выбрано</option>' + classes.map(c => `<option value="${c}">${c}</option>`).join('');
                classSelect.value = selectedFilters.class;

                const subclasses = [...new Set(filteredData.map(d => d.subclass))].sort();
                subclassSelect.innerHTML = '<option value="">Не выбрано</option>' + subclasses.map(c => `<option value="${c}">${c}</option>`).join('');
                subclassSelect.value = selectedFilters.subclass;

                const types = [...new Set(filteredData.map(d => d.type))].sort();
                typeSelect.innerHTML = '<option value="">Не выбрано</option>' + types.map(c => `<option value="${c}">${c}</option>`).join('');
                typeSelect.value = selectedFilters.type;

                const subtypes = [...new Set(filteredData.map(d => d.subtype))].sort();
                subtypeSelect.innerHTML = '<option value="">Не выбрано</option>' + subtypes.map(c => `<option value="${c}">${c}</option>`).join('');
                subtypeSelect.value = selectedFilters.subtype;

                const groups = [...new Set(filteredData.map(d => d.group))].sort();
                groupSelect.innerHTML = '<option value="">Не выбрано</option>' + groups.map(c => `<option value="${c}">${c}</option>`).join('');
                groupSelect.value = selectedFilters.group;
            }

            // Изначально все фильтры на "Не выбрано", показываем все
            updateAllFilters();

            // Обработчики изменений для каждого селекта
            classSelect.addEventListener('change', () => {
                selectedFilters.class = classSelect.value;
                updateAllFilters();
            });

            subclassSelect.addEventListener('change', () => {
                selectedFilters.subclass = subclassSelect.value;
                updateAllFilters();
            });

            typeSelect.addEventListener('change', () => {
                selectedFilters.type = typeSelect.value;
                updateAllFilters();
            });

            subtypeSelect.addEventListener('change', () => {
                selectedFilters.subtype = subtypeSelect.value;
                updateAllFilters();
            });

            groupSelect.addEventListener('change', () => {
                selectedFilters.group = groupSelect.value;
                updateAllFilters();
            });
        }

        // Рендеринг кругов (всегда отображаются)
        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Рисуем фон, если загружен
            if (background.complete && background.naturalWidth > 0) {
                ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Рисуем все круги
            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, 20, 0, 2 * Math.PI);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'rgba(0, 0, 255, 0.3)'; // Прозрачный синий
                ctx.fill();

                // Если круг мигает, меняем цвет
                if (blinkingCircleIds.includes(circle.id)) {
                    ctx.fillStyle = isBlinking ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 0, 255, 0.3)';
                    ctx.fill();
                }

                // Добавляем текст с ID
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(circle.id, circle.x, circle.y + 5);
            });
        }

        // Функция для запуска мигания кругов
        function startBlinking(circleIds) {
            blinkingCircleIds = circleIds;
            if (blinkInterval) clearInterval(blinkInterval);
            isBlinking = true;
            blinkInterval = setInterval(() => {
                isBlinking = !isBlinking;
                drawCircles();
            }, 500); // Мигание каждые 500мс
        }

        // Функция для остановки мигания
        function stopBlinking() {
            if (blinkInterval) {
                clearInterval(blinkInterval);
                blinkInterval = null;
            }
            blinkingCircleIds = [];
            isBlinking = false;
            drawCircles();
        }

        // Обработчик кнопки "Найти растение"
        document.getElementById('findPlantBtn').addEventListener('click', () => {
            // В пользовательском режиме subgroup не требуется, так как фильтр скрыт
            // Находим все круги, соответствующие выбранным фильтрам
            const filteredPlants = data.filter(plant => {
                return (!selectedFilters.class || plant.class === selectedFilters.class) &&
                       (!selectedFilters.subclass || plant.subclass === selectedFilters.subclass) &&
                       (!selectedFilters.type || plant.type === selectedFilters.type) &&
                       (!selectedFilters.subtype || plant.subtype === selectedFilters.subtype) &&
                       (!selectedFilters.group || plant.group === selectedFilters.group);
            });

            const circleIds = [...new Set(filteredPlants.map(plant => plant.subgroup))];
            if (circleIds.length > 0) {
                startBlinking(circleIds);
                document.getElementById('status').textContent = `Найдено ${circleIds.length} кругов: ${circleIds.join(', ')}`;
            } else {
                stopBlinking();
                document.getElementById('status').textContent = 'Растения не найдены.';
            }
        });

        // Обработчик кнопки "Перейти в режим разработчика"
        document.getElementById('switchToDeveloperBtn').addEventListener('click', () => {
            window.location.href = 'https://oluneva.github.io/my_site/developer.html';
        });

        // Инициализация
        async function init() {
            await loadCircles();
            await loadCSV();
            populateFilters();
            drawCircles();
            document.getElementById('status').textContent = 'Инициализация завершена.';
        }

        init();
    </script>
</body>
</html>
