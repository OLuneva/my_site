<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Добавлено: предотвращает масштабирование на мобильных и в iframe (как на GitHub Pages) -->
    <title>Пользовательский режим - Просмотр кругов</title>
    <style>
        /* Стили, адаптированные из кода разработчика: структура, цвета, размеры, расположение */
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background-color: #77c98c; /* Бледно-зелёный, как общий фон */
        }
        #container { 
            display: flex;
            flex-direction: column; 
            align-items: center; 
        }
        #content { 
            width: 100%; 
            max-width: 1200px; 
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start; 
            gap: 20px; 
        }
        #leftPanel { /* Пусто, чтобы канвас был слева */ }
        #canvasContainer { 
            flex: 1; 
            display: flex; 
            justify-content: center; 
        }
        #rightPanel { 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
        }
        #canvas { 
            border: 1px solid #000; 
            cursor: crosshair; 
        }
        #filters {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .filter-item {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 3px;
            font-size: 14px;
        }
        select { 
            padding: 5px; 
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            background-color: white;
            color: black;
            width: 100%;
        }
        #subgroupItem {
            display: none; /* Скрываем селектор "Круг" в пользовательском режиме */
        }
        button { 
            padding: 10px; 
            background-color: #808080; /* Серый цвет для кнопки */
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s ease; 
            align-self: flex-start;
        }
        button:hover { 
            background-color: #696969; /* Более темный серый при наведении */
        }
        button:active { 
            background-color: #555555; /* Еще темнее при нажатии */
        }
        #status { 
            margin-top: 10px; 
            font-size: 14px; 
            color: #555; 
            text-align: center; 
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="content">
            <div id="leftPanel"></div>
            <div id="canvasContainer">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            <div id="rightPanel">
                <div id="filters">
                    <div class="filter-item">
                        <label for="classSelect">Класс:</label>
                        <select id="classSelect"><option>Не выбрано</option></select>
                    </div>
                    <div class="filter-item">
                        <label for="subclassSelect">Семейство:</label>
                        <select id="subclassSelect"><option>Не выбрано</option></select>
                    </div>
                    <div class="filter-item">
                        <label for="typeSelect">Род:</label>
                        <select id="typeSelect"><option>Не выбрано</option></select>
                    </div>
                    <div class="filter-item">
                        <label for="subtypeSelect">Вид:</label>
                        <select id="subtypeSelect"><option>Не выбрано</option></select>
                    </div>
                    <div class="filter-item">
                        <label for="groupSelect">Сорт:</label>
                        <select id="groupSelect"><option>Не выбрано</option></select>
                    </div>
                    <div class="filter-item" id="subgroupItem">
                        <label for="subgroupSelect">Круг:</label>
                        <select id="subgroupSelect"><option>Не выбрано</option></select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Простая проверка пароля при загрузке страницы
        const PASSWORD = 'demo123';  // Замените на свой пароль

        // Глобальные переменные, как в коде разработчика (адаптировано)
        let canvas, ctx;
        let circlesData = [];  // Данные кругов (нормализованные координаты)
        let background;  // Фон как Image
        let hasBackground = false;
        let data = [];
        let selectedFilters = { class: '', subclass: '', type: '', subtype: '', group: '' }; // subgroup скрыт, не используется
        let blinkingCircleIds = [];
        let blinkInterval = null;
        let isBlinking = false;
        let blinkState = false;  // Для переключения состояния мигания
        let blinkCount = 0;  // Счетчик миганий (добавлено для ограничения на 7 раз)
        let csvLoaded = false;
        let hoveredCircle = null;  // НОВОЕ: Для отслеживания hovered круга (из кода разработчика)

        // Переменные для логических размеров Canvas (адаптивные), как в разработчике
        let logicalWidth = 800;
        let logicalHeight = 600;

        // Функция инициализации Canvas, скопированная из кода разработчика
        function initCanvas() {
            const container = document.getElementById('canvasContainer');
            const ratio = window.devicePixelRatio || 1;

            // Логические размеры на основе контейнера
            logicalWidth = container.clientWidth || 800; // Fallback на 800
            logicalHeight = container.clientHeight || 600; // Fallback на 600

            // Физические размеры с учётом масштаба устройства
            canvas.width = logicalWidth * ratio;
            canvas.height = logicalHeight * ratio;
            canvas.style.width = logicalWidth + 'px';
            canvas.style.height = logicalHeight + 'px';

            // Масштабируем контекст для корректного рисования
            ctx.scale(ratio, ratio);

            if (ratio !== 1) {
                console.log('Рекомендуется установить масштаб браузера на 100% для лучшего отображения. (Ctrl+0 или View > Actual Size)');
            }

            // Перерисовываем после инициализации
            drawCircles();
        }

        // Функция загрузки кругов из circles_export.json, адаптирована (нормализация координат как в разработчике)
        async function loadCircles() {
            try {
                console.log('Пытаюсь загрузить circles_export.json...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/circles_export.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                const loadedData = await response.json();
                circlesData = loadedData.map(c => ({
                    x: (c.x || 0) / 800, // НОРМАЛИЗУЕМ: координаты в процентах (от 0 до 1)
                    y: (c.y || 0) / 600,
                    id: String(c.id || '')
                }));  // Заполняем глобальную переменную
                console.log('Круги загружены из circles_export.json:', circlesData.length, 'кругов');
                if (circlesData.length > 0) {
                    console.log('Примеры координат (x,y нормализованные):', circlesData.slice(0, 3).map(c => `ID ${c.id}: (${c.x.toFixed(3)}, ${c.y.toFixed(3)})`));
                }
                
                // Загрузка фона и рисование кругов
                loadBackgroundAndDrawCircles();
            } catch (e) {
                console.error('Ошибка загрузки кругов:', e.message);
            }
        }

        // Функция загрузки фона, скопированная из кода разработчика
        function loadBackgroundAndDrawCircles() {
            background = new Image();  // Создаем изображение фона
            
            background.onload = () => {
                console.log('Фон загружен успешно!');
                hasBackground = true;
                drawCircles();  // Рисуем круги на фоне
            };
            
            background.onerror = () => {
                console.log('Фон не найден, используем бледно-зелёный fallback.');
                hasBackground = false;
                drawCircles();  // Рисуем на fallback фоне
            };
            
            background.src = 'https://raw.githubusercontent.com/oluneva/my_site/main/my-image.jpg';  // URL фона
        }

        // Функция рисования кругов, адаптирована из renderCircles разработчика (clear, draw background, arcs с нормализацией)
        function drawCircles() {
            ctx.clearRect(0, 0, logicalWidth, logicalHeight); // Очищаем в логических размерах
            if (hasBackground) {
                ctx.drawImage(background, 0, 0, logicalWidth, logicalHeight);
            } else {
                ctx.fillStyle = '#77c98c'; // Бледно-зелёный fallback фон
                ctx.fillRect(0, 0, logicalWidth, logicalHeight);
            }
            console.log('Рисую', circlesData.length, 'кругов...');
            circlesData.forEach(circle => {
                // МАСШТАБИРУЕМ координаты: проценты -> пиксели
                const x = circle.x * logicalWidth;
                const y = circle.y * logicalHeight;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);  // Радиус 15px, как в разработчике
                // НОВОЕ: Цвет с приоритетом на hover (синий), затем мигание (красный), иначе оранжевый
                if (hoveredCircle && hoveredCircle.id === circle.id) {
                    ctx.fillStyle = 'blue';  // Подсветка при наведении
                } else if (blinkingCircleIds.includes(circle.id) && isBlinking && blinkState) {
                    ctx.fillStyle = 'red';  // Мигающие круги красные
                } else {
                    ctx.fillStyle = 'orange';  // Обычные круги оранжевые
                }
                ctx.fill();
                ctx.stroke();  // Добавлен stroke для контура, как в разработчике
                
                // НОВОЕ: Отображение названия сорта при наведении (из кода разработчика)
                if (hoveredCircle && hoveredCircle.id === circle.id) {
                    const csvEntry = data.find(d => d['круг'] === circle.id);  // Ищем по ключу 'круг' (в нижнем регистре из парсинга)
                    if (csvEntry && csvEntry['сорт']) {
                        ctx.fillStyle = 'black';
                        ctx.font = '12px Arial';
                        ctx.fillText(csvEntry['сорт'], x + 20, y - 10);  // Текст рядом с кругом
                    }
                }
            });
            console.log('Круги нарисованы.');
        }

        // Функция загрузки данных из CSV, без изменений (логика сохранена)
        async function loadCSV() {
            try {
                console.log('Пытаюсь загрузить Plants.csv...');
                const response = await fetch('https://raw.githubusercontent.com/oluneva/my_site/main/Plants.csv');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                // Декодируем как Windows-1251 (CP1251), чтобы корректно прочитать русские буквы
                const buffer = await response.arrayBuffer();
                const decoder = new TextDecoder('windows-1251');  // Для CP1251; если другая кодировка, замените (например, 'iso-8859-5')
                const csvText = decoder.decode(buffer);
                
                data = parseCSV(csvText);
                console.log('CSV загружено:', data.length, 'записей');
                if (data.length > 0) {
                    console.log('Примеры данных:', data.slice(0, 3));
                }
                populateFilters();
                csvLoaded = true;
            } catch (e) {
                console.error('Ошибка загрузки CSV:', e.message);
                alert('Не удалось загрузить данные растений. Проверьте консоль браузера.');
            }
        }

        // Функция парсинга CSV с разделителем ";", без изменений
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n').filter(line => line.trim() !== ''); // Убираем пустые строки
            if (lines.length < 2) {
                console.warn('CSV пустой или содержит только заголовки');
                return [];
            }
            const headers = lines[0].split(';').map(h => h.trim());
            console.log('Заголовки CSV:', headers); // Лог заголовков для проверки
            const expectedHeaders = ['Класс', 'Семейство', 'Род', 'Вид', 'Сорт', 'Круг'];
            // Гибкая проверка: если заголовки не точные, но есть похожие, продолжаем
            if (!headers.some(h => h.toLowerCase().includes('класс'))) {
                console.warn('Заголовки CSV не содержат "Класс". Проверьте файл.');
                return [];
            }
            return lines.slice(1).map(line => {
                const values = line.split(';').map(v => v.trim());
                if (values.length !== headers.length) {
                    console.warn('Некорректная строка CSV:', line);
                    return null;
                }
                const row = {};
                headers.forEach((header, index) => {
                    row[header.toLowerCase()] = values[index]; // Ключи в нижнем регистре для удобства
                });
                return row;
            }).filter(row => row !== null);
        }

        // Функция заполнения селекторов, изменена: теперь только listeners и начальный updateFilters()
        function populateFilters() {
            if (data.length === 0) return;

            // Обработчики изменения - с проверкой на 'Не выбрано' и вызовом updateFilters() + filterData()
            const classSelect = document.getElementById('classSelect');
            classSelect.addEventListener('change', () => {
                selectedFilters.class = classSelect.value === 'Не выбрано' ? '' : classSelect.value;
                updateFilters();
                filterData();
            });

            const subclassSelect = document.getElementById('subclassSelect');
            subclassSelect.addEventListener('change', () => {
                selectedFilters.subclass = subclassSelect.value === 'Не выбрано' ? '' : subclassSelect.value;
                updateFilters();
                filterData();
            });

            const typeSelect = document.getElementById('typeSelect');
            typeSelect.addEventListener('change', () => {
                selectedFilters.type = typeSelect.value === 'Не выбрано' ? '' : typeSelect.value;
                updateFilters();
                filterData();
            });

            const subtypeSelect = document.getElementById('subtypeSelect');
            subtypeSelect.addEventListener('change', () => {
                selectedFilters.subtype = subtypeSelect.value === 'Не выбрано' ? '' : subtypeSelect.value;
                updateFilters();
                filterData();
            });

            const groupSelect = document.getElementById('groupSelect');
            groupSelect.addEventListener('change', () => {
                selectedFilters.group = groupSelect.value === 'Не выбрано' ? '' : groupSelect.value;
                updateFilters();
                filterData();
            });

            // Начальное обновление всех селекторов (на основе пустых selectedFilters)
            updateFilters();
        }

        // Новая функция для синхронизации selectedFilters с значениями селекторов (вызывается в конце updateFilters)
        function syncSelectedFilters() {
            const classSelect = document.getElementById('classSelect');
            const subclassSelect = document.getElementById('subclassSelect');
            const typeSelect = document.getElementById('typeSelect');
            const subtypeSelect = document.getElementById('subtypeSelect');
            const groupSelect = document.getElementById('groupSelect');

            selectedFilters.class = classSelect.value === 'Не выбрано' ? '' : classSelect.value;
            selectedFilters.subclass = subclassSelect.value === 'Не выбрано' ? '' : subclassSelect.value;
            selectedFilters.type = typeSelect.value === 'Не выбрано' ? '' : typeSelect.value;
            selectedFilters.subtype = subtypeSelect.value === 'Не выбрано' ? '' : subtypeSelect.value;
            selectedFilters.group = groupSelect.value === 'Не выбрано' ? '' : groupSelect.value;
        }

        // Обновленная функция для каскадного обновления селекторов (гибкая логика: все селекторы обновляются на основе ВСЕХ выбранных фильтров, кроме сорта - на основе верхних)
        function updateFilters() {
            if (data.length === 0) return;

            // Шаг 1: Фильтруем данные по ВСЕМ текущим выбранным фильтрам (независимо от уровня) - для верхних селекторов
            const filteredData = data.filter(d => {
                return (!selectedFilters.class || d['класс'] === selectedFilters.class) &&
                       (!selectedFilters.subclass || d['семейство'] === selectedFilters.subclass) &&
                       (!selectedFilters.type || d['род'] === selectedFilters.type) &&
                       (!selectedFilters.subtype || d['вид'] === selectedFilters.subtype) &&
                       (!selectedFilters.group || d['сорт'] === selectedFilters.group);
            });

            // Шаг 2: Фильтруем данные только по верхним фильтрам (class, subclass, type, subtype) - для сорта
            const upperFilteredData = data.filter(d => {
                return (!selectedFilters.class || d['класс'] === selectedFilters.class) &&
                       (!selectedFilters.subclass || d['семейство'] === selectedFilters.subclass) &&
                       (!selectedFilters.type || d['род'] === selectedFilters.type) &&
                       (!selectedFilters.subtype || d['вид'] === selectedFilters.subtype);
            });

            // Шаг 3: Обновляем верхние селекторы на основе filteredData
            const classSelect = document.getElementById('classSelect');
            const classes = [...new Set(filteredData.map(d => d['класс']).filter(Boolean))];
            populateSelect(classSelect, classes, selectedFilters.class);

            const subclassSelect = document.getElementById('subclassSelect');
            const subclasses = [...new Set(filteredData.map(d => d['семейство']).filter(Boolean))];
            populateSelect(subclassSelect, subclasses, selectedFilters.subclass);

            const typeSelect = document.getElementById('typeSelect');
            const types = [...new Set(filteredData.map(d => d['род']).filter(Boolean))];
            populateSelect(typeSelect, types, selectedFilters.type);

            const subtypeSelect = document.getElementById('subtypeSelect');
            const subtypes = [...new Set(filteredData.map(d => d['вид']).filter(Boolean))];
            populateSelect(subtypeSelect, subtypes, selectedFilters.subtype);

            // Шаг 4: Обновляем селектор сорта на основе upperFilteredData (всегда показывает все сорта, совместимые с верхними фильтрами, независимо от выбранного сорта)
            const groupSelect = document.getElementById('groupSelect');
            const groups = [...new Set(upperFilteredData.map(d => d['сорт']).filter(Boolean))];
            populateSelect(groupSelect, groups, selectedFilters.group);

            // Шаг 5: Синхронизируем selectedFilters с актуальными значениями селекторов (сброс, если опция больше не доступна)
            syncSelectedFilters();

            console.log('Фильтры обновлены. Filtered data:', filteredData.length, 'Upper filtered data for group:', upperFilteredData.length);
        }

        // Функция заполнения одного селектора, без изменений (с сохранением выбора)
        function populateSelect(select, options, selectedValue = '') {
            const currentValue = select.value; // Сохраняем текущий выбор (хотя теперь используется selectedValue)
            select.innerHTML = '<option>Не выбрано</option>';
            options.sort().forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                select.appendChild(opt);
            });
            // Восстанавливаем выбор, если он в опциях, иначе "Не выбрано"
            if (selectedValue && options.includes(selectedValue)) {
                select.value = selectedValue;
            } else {
                select.value = 'Не выбрано';
            }
        }

        // Функция фильтрации данных и поиска кругов, изменена: мигание только если выбран сорт
        function filterData() {
            if (!csvLoaded || data.length === 0) {
                console.warn('Данные ещё не загружены');
                return;
            }
            const filtered = data.filter(d => {
                return (!selectedFilters.class || d['класс'] === selectedFilters.class) &&
                       (!selectedFilters.subclass || d['семейство'] === selectedFilters.subclass) &&
                       (!selectedFilters.type || d['род'] === selectedFilters.type) &&
                       (!selectedFilters.subtype || d['вид'] === selectedFilters.subtype) &&
                       (!selectedFilters.group || d['сорт'] === selectedFilters.group);
            });
            console.log('Отфильтрованные данные:', filtered.length);
            blinkingCircleIds = filtered.map(d => d['круг']).filter(id => id && circlesData.some(c => c.id == id));  // Исправлено на circlesData
            console.log('Мигающие круги:', blinkingCircleIds);
            // Мигание только если выбран сорт И есть круги
            if (selectedFilters.group && blinkingCircleIds.length > 0) {
                startBlinking();
            } else {
                stopBlinking();
            }
        }

        // Функции мигания, изменены: теперь мигание происходит ровно 7 раз
        function startBlinking() {
            if (blinkInterval) clearInterval(blinkInterval);
            isBlinking = true;
            blinkState = false;  // Начинаем с обычного состояния
            blinkCount = 0;  // Сбрасываем счетчик
            blinkInterval = setInterval(() => {
                blinkState = !blinkState;
                blinkCount++;
                drawCircles();
                if (blinkCount >= 7) {  // После 7 миганий останавливаемся
                    stopBlinking();
                }
            }, 500); // Каждые 500мс
        }

        function stopBlinking() {
            isBlinking = false;
            blinkState = false;  // Возвращаем к обычному
            blinkCount = 0;  // Сбрасываем счетчик
            if (blinkInterval) {
                clearInterval(blinkInterval);
                blinkInterval = null;
            }
            drawCircles(); // Перерисовываем без мигания
        }

        // Инициализация, адаптирована (initCanvas + load, как в разработчике)
        async function init() {
            canvas = document.getElementById('canvas');  // Инициализируем здесь, после загрузки DOM
            if (!canvas) {
                console.error('Канвас не найден!');
                alert('Ошибка: канвас не найден. Проверьте HTML.');
                return;
            }
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Не удалось получить контекст 2D для канваса!');
                alert('Ошибка: не удалось инициализировать канвас.');
                return;
            }
            initCanvas();  // Инициализируем размеры canvas
            await loadCircles();  // Загружаем круги и фон
            await loadCSV();  // Загружаем CSV
            
            // НОВОЕ: Обработчик mousemove для hover (из кода разработчика, адаптировано)
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / logicalWidth;  // Нормализованные координаты
                const y = (e.clientY - rect.top) / logicalHeight;
                const prevHovered = hoveredCircle;
                hoveredCircle = circlesData.find(c => Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 15 / logicalWidth);  // Радиус 15px в процентах
                if (prevHovered !== hoveredCircle) {
                    drawCircles();  // Перерисовываем только если изменилось
                }
            });
        }

        window.onload = function() {
            const enteredPassword = prompt('Введите пароль для доступа к пользовательскому режиму:');
            if (enteredPassword !== PASSWORD) {
                alert('Неверный пароль. Доступ запрещён.');
                document.body.innerHTML = '<h1 style="text-align: center; padding-top: 50px; color: black;">Доступ запрещён</h1>';  // Черный текст на светлом фоне
                return;
            }
            // Если пароль верный, инициализируем сайт
            init();
        };

        // Обработка изменения размера окна, скопировано из разработчика
        window.addEventListener('resize', initCanvas);
    </script>
</body>
</html>
